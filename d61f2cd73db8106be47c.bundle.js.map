{"version":3,"sources":["webpack://wettma/./src/state/state.ts","webpack://wettma/./src/environment.ts","webpack://wettma/./src/state/worker.ts"],"names":["RequestState","serverUrl","environment","state","upcomingGames","goToLogin","goToRegister","accessToken","displayName","userId","register","Unset","_odds","updateState","updateFn","self","postMessage","async","getGames","syncGamesTask","headers","Headers","append","token","gamesRes","fetch","games","json","s","filter","g","result","map","oldGame","find","o","id","team1","team2","time","Date","myBet","choice","odds","team1Odds","team2Odds","draw","drawOdds","sort","a","b","syncGames","getOddsTask","oddsRes","getOdds","_","Promise","all","game","gameId","idx","indexOf","updateUpcomingGame","update","initializeAccessToken","res","status","userProfile","addEventListener","ev","msg","type","foundOdds","oddsId","saving","saveError","method","body","JSON","stringify","err","oddsChanged","gameStarted","unknown","createBet","initialize","InProgress","Successful","Failed","smg","navigator","credentials","preventSilentAccess","logout","handleMessage","data","catch","console","error"],"mappings":"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","file":"d61f2cd73db8106be47c.bundle.js","sourcesContent":["import { AccessToken } from \"../AccessToken\";\nimport { UpcomingGame } from \"../models/UpcomingGame\";\n\nexport enum RequestState {\n    Unset,\n    InProgress,\n    Successful,\n    Failed,\n}\n\nexport interface State {\n    goToLogin: boolean;\n    upcomingGames: UpcomingGame[];\n    accessToken: AccessToken;\n    goToRegister: boolean;\n    displayName: string;\n    userId: string;\n    register: RequestState;\n}\n","let serverUrl: string;\n\nif (__ENVIRONMENT == \"local\") {\n    serverUrl = \"https://wettma.azurewebsites.net\";\n}\nelse if (__ENVIRONMENT == \"gh-pages\") {\n    serverUrl = \"https://wettma.azurewebsites.net\";\n}\n\nexport const environment = {\n    serverUrl: serverUrl\n};\n","import { RequestState, State } from \"./state\";\nimport { LoginPageOpened } from \"./requests/LoginPageOpened\";\nimport { CreateBetAction } from \"./requests/CreateBetAction\";\nimport { ActionType } from \"./requests/ActionType\";\nimport { environment } from \"../environment\";\nimport { Game, Odds, Profile } from \"../api/models\";\nimport { Initialize } from \"./requests/Initialize\";\nimport { RegisterAction } from \"./requests/RegisterAction\";\nimport { AccessToken } from \"../AccessToken\";\nimport { LogoutAction } from \"./requests/LogoutAction\";\nimport { UpcomingGame } from \"../models/UpcomingGame\";\n\nlet state: State = {\n    upcomingGames: [],\n    goToLogin: false,\n    goToRegister: false,\n    accessToken: null,\n    displayName: null,\n    userId: null,\n    register: RequestState.Unset,\n};\n\nlet _odds: Odds[] = [];\n\nfunction updateState(updateFn: (oldState: State) => State) {\n    state = updateFn(state);\n    self.postMessage(state);\n}\n\ntype Actions = CreateBetAction\n    | LoginPageOpened\n    | Initialize\n    | RegisterAction\n    | LogoutAction;\n\nasync function syncGames() {\n    let headers = new Headers();\n    if (state.accessToken) {\n        headers.append(\"Authorization\", `Bearer ${state.accessToken.token}`);\n    }\n    let gamesRes = await fetch(`${environment.serverUrl}/games`, { headers: headers });\n    let games: Game[] = await gamesRes.json();\n    updateState(s => {\n        return {\n            ...s,\n            upcomingGames: games.filter(g => !g.result).map(g => {\n                let oldGame = s.upcomingGames.find(o => o.id == g.id);\n                return {\n                    ...oldGame,\n                    id: g.id,\n                    team1: g.team1,\n                    team2: g.team2,\n                    time: new Date(g.time),\n                    myBet: g.myBet ? {\n                        choice: g.myBet.choice,\n                        odds: {\n                            team1: g.myBet.odds.team1Odds,\n                            team2: g.myBet.odds.team2Odds,\n                            draw: g.myBet.odds.drawOdds\n                        }\n                    } : null\n                };\n            }).sort((a, b) => +a.time - +b.time)\n        }\n    });\n}\n\nasync function getOdds() {\n    let oddsRes = await fetch(`${environment.serverUrl}/odds`);\n    _odds = await oddsRes.json();\n    return _odds;\n}\n\nasync function getGames() {\n    let syncGamesTask = syncGames();\n    let getOddsTask = getOdds();\n    let [_, odds] = await Promise.all([syncGamesTask, getOddsTask]);\n    updateState(s => {\n        let upcomingGames = [...s.upcomingGames];\n        for (let o of odds) {\n            let game = upcomingGames.find(g => o.gameId == g.id);\n            if (game) {\n                let idx = upcomingGames.indexOf(game);\n                upcomingGames[idx] = {\n                    ...game, odds: {\n                        draw: o.drawOdds,\n                        id: o.id,\n                        team1: o.team1Odds,\n                        team2: o.team2Odds,\n                    }\n                };\n            }\n        }\n        return {\n            ...s,\n            upcomingGames: upcomingGames\n        }\n    });\n}\n\nfunction updateUpcomingGame(id: number, update: Partial<UpcomingGame>) {\n    updateState(s => {\n        let upcomingGames = [...s.upcomingGames];\n        let game = upcomingGames.find(g => id == g.id);\n        let idx = upcomingGames.indexOf(game);\n        upcomingGames[idx] = {\n            ...game,\n            ...update\n        };\n        return {\n            ...s,\n            upcomingGames: upcomingGames\n        };\n    });\n}\n\nasync function createBet(msg: CreateBetAction) {\n    let foundOdds = _odds.find(o => o.id == msg.oddsId);\n    updateUpcomingGame(foundOdds.gameId, { saving: true, saveError: null });\n    if (null == state.accessToken) {\n        updateState(s => { return { ...s, goToLogin: true } });\n    } else if (null == state.userId) {\n        updateState(s => { return { ...s, goToRegister: true } });\n    }\n    try {\n        let res = await fetch(`${environment.serverUrl}/bets`, {\n            headers: {\n                \"Authorization\": `Bearer ${state.accessToken.token}`,\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify({ oddsId: msg.oddsId, choice: msg.choice })\n        });\n        if (res.status == 200) {\n            updateUpcomingGame(foundOdds.gameId, {\n                myBet: {\n                    choice: msg.choice,\n                    odds: {\n                        draw: foundOdds.drawOdds,\n                        team1: foundOdds.team1Odds,\n                        team2: foundOdds.team2Odds\n                    }\n                },\n                saving: false\n            });\n        } else if (res.status == 400) {\n            let err: { type: string } = await res.json();\n            if (err.type == \"oddschanged\" ||err.type== \"oddsexpired\") {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: {\n                        oddsChanged: true\n                    }\n                });\n                await getGames();\n            } else if (err.type == \"gamestarted\") {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: {\n                        gameStarted: true\n                    }\n                });\n                await getGames();\n            } else {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: { unknown: true }\n                });\n            }\n        }\n    } catch (err) {\n        updateUpcomingGame(foundOdds.gameId, {\n            saving: false, saveError: { unknown: true }\n        });\n    }\n}\n\nasync function initializeAccessToken(accessToken: AccessToken) {\n    let res = await fetch(`${environment.serverUrl}/user/profile`, {\n        headers: {\n            \"Authorization\": `Bearer ${accessToken.token}`\n        }\n    });\n    if (res.status == 401) {\n        updateState(s => {\n            return {\n                ...s,\n                goToRegister: true,\n                accessToken: accessToken\n            };\n        });\n    } else if (res.status == 200) {\n        let userProfile: Profile = await res.json();\n        updateState(s => {\n            return {\n                ...s,\n                accessToken: accessToken,\n                userId: userProfile.userId,\n                displayName: userProfile.displayName\n            };\n        });\n        return true;\n    }\n    return false;\n\n}\n\nasync function initialize(accessToken: AccessToken) {\n    if (accessToken) {\n        await initializeAccessToken(accessToken);\n    }\n    await getGames();\n}\n\nasync function register(msg: RegisterAction) {\n    updateState(s => { return { ...s, register: RequestState.InProgress, goToRegister: false } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/user/register`, {\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify({ displayName: msg.displayName, token: state.accessToken.token })\n        });\n        if (res.status == 201) {\n            if (await initializeAccessToken(state.accessToken)) {\n                updateState(s => { return { ...s, register: RequestState.Successful } });\n            }\n        } else {\n            updateState(s => { return { ...s, register: RequestState.Failed } });\n        }\n    } catch (err) {\n        updateState(s => { return { ...s, register: RequestState.Failed } });\n    }\n}\n\nasync function logout(smg: LogoutAction) {\n    if (\"credentials\" in navigator && \"preventSilentAccess\" in navigator.credentials) {\n        navigator.credentials.preventSilentAccess();\n    }\n    updateState(s => {\n        return {\n            ...s,\n            accessToken: null,\n            displayName: null,\n            userId: null\n        }\n    });\n    await getGames();\n}\n\nasync function handleMessage(msg: Actions) {\n    switch (msg.type) {\n        case ActionType.CreateBet:\n            await createBet(msg);\n            break;\n        case ActionType.LoginPageOpened:\n            updateState(s => { return { ...s, goToLogin: false } });\n            break;\n        case ActionType.Initialize:\n            await initialize(msg.accessToken);\n            break;\n        case ActionType.Register:\n            await register(msg);\n            break;\n        case ActionType.Logout:\n            await logout(msg);\n    }\n}\n\nself.addEventListener(\"message\", ev => {\n    let msg: Actions = ev.data;\n    handleMessage(msg).catch(err => console.error(err));\n});"],"sourceRoot":""}