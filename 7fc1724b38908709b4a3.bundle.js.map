{"version":3,"sources":["webpack://wettma/./src/state/state.ts","webpack://wettma/./src/environment.ts","webpack://wettma/./src/state/worker.ts"],"names":["RequestState","serverUrl","environment","state","upcomingGames","goToLogin","goToRegister","accessToken","displayName","userId","register","Unset","scoreboard","scoreboardRequest","_odds","updateState","updateFn","self","postMessage","async","getGames","syncGamesTask","headers","Headers","append","token","gamesRes","fetch","games","json","s","filter","g","result","map","oldGame","find","o","id","team1","team2","time","Date","myBet","choice","odds","team1Odds","team2Odds","draw","drawOdds","sort","a","b","syncGames","getOddsTask","oddsRes","getOdds","_","Promise","all","game","gameId","idx","indexOf","updateUpcomingGame","update","initializeAccessToken","res","status","userProfile","addEventListener","ev","msg","type","foundOdds","oddsId","saving","saveError","method","body","JSON","stringify","err","oddsChanged","gameStarted","unknown","createBet","initialize","InProgress","Successful","Failed","smg","navigator","credentials","preventSilentAccess","logout","ok","points","localeCompare","updateScoreboard","handleMessage","data","catch","console","error"],"mappings":"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","file":"7fc1724b38908709b4a3.bundle.js","sourcesContent":["import { AccessToken } from \"../AccessToken\";\nimport { ScoreboardEntry } from \"../models/ScoreboardEntry\";\nimport { UpcomingGame } from \"../models/UpcomingGame\";\n\nexport enum RequestState {\n    Unset,\n    InProgress,\n    Successful,\n    Failed,\n}\n\nexport interface State {\n    goToLogin: boolean;\n    upcomingGames: UpcomingGame[];\n    accessToken: AccessToken;\n    goToRegister: boolean;\n    displayName: string;\n    userId: string;\n    register: RequestState;\n    scoreboardRequest: RequestState;\n    scoreboard: ScoreboardEntry[];\n}\n","let serverUrl: string;\n\nif (__ENVIRONMENT == \"local\") {\n    serverUrl = \"https://wettma.azurewebsites.net\"; \"https://localhost:44308\";\n}\nelse if (__ENVIRONMENT == \"gh-pages\") {\n    serverUrl = \"https://wettma.azurewebsites.net\";\n}\n\nexport const environment = {\n    serverUrl: serverUrl\n};\n","import { RequestState, State } from \"./state\";\nimport { LoginPageOpened } from \"./requests/LoginPageOpened\";\nimport { CreateBetAction } from \"./requests/CreateBetAction\";\nimport { ActionType } from \"./requests/ActionType\";\nimport { environment } from \"../environment\";\nimport { Game, Odds, Profile, ScoreboardEntry } from \"../api/models\";\nimport { Initialize } from \"./requests/Initialize\";\nimport { RegisterAction } from \"./requests/RegisterAction\";\nimport { AccessToken } from \"../AccessToken\";\nimport { LogoutAction } from \"./requests/LogoutAction\";\nimport { UpcomingGame } from \"../models/UpcomingGame\";\nimport { UpdateScoreboardAction } from \"./requests/UpdateScoreboardAction\";\n\nlet state: State = {\n    upcomingGames: [],\n    goToLogin: false,\n    goToRegister: false,\n    accessToken: null,\n    displayName: null,\n    userId: null,\n    register: RequestState.Unset,\n    scoreboard: [],\n    scoreboardRequest: RequestState.Unset\n};\n\nlet _odds: Odds[] = [];\n\nfunction updateState(updateFn: (oldState: State) => State) {\n    state = updateFn(state);\n    self.postMessage(state);\n}\n\ntype Actions = CreateBetAction\n    | LoginPageOpened\n    | Initialize\n    | RegisterAction\n    | LogoutAction\n    | UpdateScoreboardAction;\n\nasync function syncGames() {\n    let headers = new Headers();\n    if (state.accessToken) {\n        headers.append(\"Authorization\", `Bearer ${state.accessToken.token}`);\n    }\n    let gamesRes = await fetch(`${environment.serverUrl}/games`, { headers: headers });\n    let games: Game[] = await gamesRes.json();\n    updateState(s => {\n        return {\n            ...s,\n            upcomingGames: games.filter(g => !g.result).map(g => {\n                let oldGame = s.upcomingGames.find(o => o.id == g.id);\n                return {\n                    ...oldGame,\n                    id: g.id,\n                    team1: g.team1,\n                    team2: g.team2,\n                    time: new Date(g.time),\n                    myBet: g.myBet ? {\n                        choice: g.myBet.choice,\n                        odds: {\n                            team1: g.myBet.odds.team1Odds,\n                            team2: g.myBet.odds.team2Odds,\n                            draw: g.myBet.odds.drawOdds\n                        }\n                    } : null\n                };\n            }).sort((a, b) => +a.time - +b.time)\n        }\n    });\n}\n\nasync function getOdds() {\n    let oddsRes = await fetch(`${environment.serverUrl}/odds`);\n    _odds = await oddsRes.json();\n    return _odds;\n}\n\nasync function getGames() {\n    let syncGamesTask = syncGames();\n    let getOddsTask = getOdds();\n    let [_, odds] = await Promise.all([syncGamesTask, getOddsTask]);\n    updateState(s => {\n        let upcomingGames = [...s.upcomingGames];\n        for (let o of odds) {\n            let game = upcomingGames.find(g => o.gameId == g.id);\n            if (game && +game.time > (+new Date() - 5 * 60000)) {\n                let idx = upcomingGames.indexOf(game);\n                upcomingGames[idx] = {\n                    ...game, odds: {\n                        draw: o.drawOdds,\n                        id: o.id,\n                        team1: o.team1Odds,\n                        team2: o.team2Odds,\n                    }\n                };\n            }\n        }\n        return {\n            ...s,\n            upcomingGames: upcomingGames\n        }\n    });\n}\n\nfunction updateUpcomingGame(id: number, update: Partial<UpcomingGame>) {\n    updateState(s => {\n        let upcomingGames = [...s.upcomingGames];\n        let game = upcomingGames.find(g => id == g.id);\n        let idx = upcomingGames.indexOf(game);\n        upcomingGames[idx] = {\n            ...game,\n            ...update\n        };\n        return {\n            ...s,\n            upcomingGames: upcomingGames\n        };\n    });\n}\n\nasync function createBet(msg: CreateBetAction) {\n    let foundOdds = _odds.find(o => o.id == msg.oddsId);\n    updateUpcomingGame(foundOdds.gameId, { saving: true, saveError: null });\n    if (null == state.accessToken) {\n        updateState(s => { return { ...s, goToLogin: true } });\n    } else if (null == state.userId) {\n        updateState(s => { return { ...s, goToRegister: true } });\n    }\n    try {\n        let res = await fetch(`${environment.serverUrl}/bets`, {\n            headers: {\n                \"Authorization\": `Bearer ${state.accessToken.token}`,\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify({ oddsId: msg.oddsId, choice: msg.choice })\n        });\n        if (res.status == 200) {\n            updateUpcomingGame(foundOdds.gameId, {\n                myBet: {\n                    choice: msg.choice,\n                    odds: {\n                        draw: foundOdds.drawOdds,\n                        team1: foundOdds.team1Odds,\n                        team2: foundOdds.team2Odds\n                    }\n                },\n                saving: false\n            });\n        } else if (res.status == 400) {\n            let err: { type: string } = await res.json();\n            if (err.type == \"oddschanged\" || err.type == \"oddsexpired\") {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: {\n                        oddsChanged: true\n                    }\n                });\n                await getGames();\n            } else if (err.type == \"gamestarted\") {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: {\n                        gameStarted: true\n                    }\n                });\n                await getGames();\n            } else {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: { unknown: true }\n                });\n            }\n        }\n    } catch (err) {\n        updateUpcomingGame(foundOdds.gameId, {\n            saving: false, saveError: { unknown: true }\n        });\n    }\n}\n\nasync function initializeAccessToken(accessToken: AccessToken) {\n    let res = await fetch(`${environment.serverUrl}/user/profile`, {\n        headers: {\n            \"Authorization\": `Bearer ${accessToken.token}`\n        }\n    });\n    if (res.status == 401) {\n        updateState(s => {\n            return {\n                ...s,\n                goToRegister: true,\n                accessToken: accessToken\n            };\n        });\n    } else if (res.status == 200) {\n        let userProfile: Profile = await res.json();\n        updateState(s => {\n            return {\n                ...s,\n                accessToken: accessToken,\n                userId: userProfile.userId,\n                displayName: userProfile.displayName\n            };\n        });\n        return true;\n    }\n    return false;\n\n}\n\nasync function initialize(accessToken: AccessToken) {\n    if (accessToken) {\n        await initializeAccessToken(accessToken);\n    }\n    await getGames();\n}\n\nasync function register(msg: RegisterAction) {\n    updateState(s => { return { ...s, register: RequestState.InProgress, goToRegister: false } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/user/register`, {\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify({ displayName: msg.displayName, token: state.accessToken.token })\n        });\n        if (res.status == 201) {\n            if (await initializeAccessToken(state.accessToken)) {\n                updateState(s => { return { ...s, register: RequestState.Successful } });\n            }\n        } else {\n            updateState(s => { return { ...s, register: RequestState.Failed } });\n        }\n    } catch (err) {\n        updateState(s => { return { ...s, register: RequestState.Failed } });\n    }\n}\n\nasync function logout(smg: LogoutAction) {\n    if (\"credentials\" in navigator && \"preventSilentAccess\" in navigator.credentials) {\n        navigator.credentials.preventSilentAccess();\n    }\n    updateState(s => {\n        return {\n            ...s,\n            accessToken: null,\n            displayName: null,\n            userId: null\n        }\n    });\n    await getGames();\n}\n\nasync function updateScoreboard(msg: UpdateScoreboardAction) {\n    updateState(s => { return { ...s, scoreboardRequest: RequestState.InProgress } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/scoreboard`);\n        if (!res.ok) {\n            updateState(s => { return { ...s, scoreboardRequest: RequestState.Failed } });\n            return;\n        }\n        let content: ScoreboardEntry[] = await res.json();\n        let scoreboard = content.sort((a, b) => {\n            return b.points - a.points || a.displayName.localeCompare(b.displayName);\n        }).map(s => {\n            return {\n                displayName: s.displayName,\n                points: s.points,\n                userId: s.userId\n            };\n        })\n        updateState(s => {\n            return {\n                ...s,\n                scoreboardRequest: RequestState.Successful,\n                scoreboard: scoreboard\n            }\n        });\n    } catch (err) {\n        updateState(s => { return { ...s, scoreboardRequest: RequestState.Failed } });\n    }\n}\n\nasync function handleMessage(msg: Actions) {\n    switch (msg.type) {\n        case ActionType.CreateBet:\n            await createBet(msg);\n            break;\n        case ActionType.LoginPageOpened:\n            updateState(s => { return { ...s, goToLogin: false } });\n            break;\n        case ActionType.Initialize:\n            await initialize(msg.accessToken);\n            break;\n        case ActionType.Register:\n            await register(msg);\n            break;\n        case ActionType.Logout:\n            await logout(msg);\n            break;\n        case ActionType.UpdateScoreboard:\n            await updateScoreboard(msg);\n            break;\n    }\n}\n\nself.addEventListener(\"message\", ev => {\n    let msg: Actions = ev.data;\n    handleMessage(msg).catch(err => console.error(err));\n});"],"sourceRoot":""}