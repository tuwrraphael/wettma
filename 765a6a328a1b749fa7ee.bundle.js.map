{"version":3,"sources":["webpack://wettma/./src/state/state.ts","webpack://wettma/./src/environment.ts","webpack://wettma/./src/state/worker.ts"],"names":["RequestState","serverUrl","environment","state","upcomingGames","goToLogin","goToRegister","accessToken","displayName","userId","register","Unset","scoreboard","scoreboardRequest","setResultRequest","finishedGames","gameBets","_odds","updateState","updateFn","self","postMessage","async","getGames","syncGamesTask","headers","Headers","append","token","gamesRes","fetch","games","json","s","filter","g","result","map","oldGame","find","o","id","team1","team2","time","Date","myBet","choice","odds","team1Odds","team2Odds","draw","drawOdds","sort","a","b","team1Goals","team2Goals","syncGames","getOddsTask","oddsRes","getOdds","_","Promise","all","game","gameId","idx","indexOf","updateUpcomingGame","update","initializeAccessToken","res","status","userProfile","addEventListener","ev","msg","type","foundOdds","oddsId","saving","saveError","method","body","JSON","stringify","err","oddsChanged","gameStarted","unknown","createBet","initialize","InProgress","Successful","Failed","smg","navigator","credentials","preventSilentAccess","logout","ok","points","localeCompare","updateScoreboard","setResult","requestState","content","bets","getGameBets","handleMessage","data","catch","console","error"],"mappings":"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","file":"765a6a328a1b749fa7ee.bundle.js","sourcesContent":["import { AccessToken } from \"../AccessToken\";\nimport { ScoreboardEntry } from \"../models/ScoreboardEntry\";\nimport { UpcomingGame } from \"../models/UpcomingGame\";\nimport { FinishedGame } from \"../models/FinishedGame\";\nimport { GameBets } from \"../models/GameBets\";\n\nexport enum RequestState {\n    Unset,\n    InProgress,\n    Successful,\n    Failed\n}\n\nexport interface State {\n    goToLogin: boolean;\n    upcomingGames: UpcomingGame[];\n    finishedGames: FinishedGame[];\n    accessToken: AccessToken;\n    goToRegister: boolean;\n    displayName: string;\n    userId: string;\n    register: RequestState;\n    scoreboardRequest: RequestState;\n    scoreboard: ScoreboardEntry[];\n    setResultRequest: RequestState;\n    gameBets: { [gameId: number]: GameBets }\n}\n","let serverUrl: string;\n\nif (__ENVIRONMENT == \"local\") {\n    serverUrl = \"https://localhost:44308\";\n}\nelse if (__ENVIRONMENT == \"gh-pages\") {\n    serverUrl = \"https://wettma.azurewebsites.net\";\n}\n\nexport const environment = {\n    serverUrl: serverUrl\n};\n","import { RequestState, State } from \"./state\";\nimport { LoginPageOpened } from \"./requests/LoginPageOpened\";\nimport { CreateBetAction } from \"./requests/CreateBetAction\";\nimport { ActionType } from \"./requests/ActionType\";\nimport { environment } from \"../environment\";\nimport { Game, Odds, Profile, ScoreboardEntry, UserBet } from \"../api/models\";\nimport { Initialize } from \"./requests/Initialize\";\nimport { RegisterAction } from \"./requests/RegisterAction\";\nimport { AccessToken } from \"../AccessToken\";\nimport { LogoutAction } from \"./requests/LogoutAction\";\nimport { UpcomingGame } from \"../models/UpcomingGame\";\nimport { UpdateScoreboardAction } from \"./requests/UpdateScoreboardAction\";\nimport { SetResultAction } from \"./requests/SetResultAction\";\nimport { ShowGameBets } from \"./requests/ShowGameBets\";\n\nlet state: State = {\n    upcomingGames: [],\n    goToLogin: false,\n    goToRegister: false,\n    accessToken: null,\n    displayName: null,\n    userId: null,\n    register: RequestState.Unset,\n    scoreboard: [],\n    scoreboardRequest: RequestState.Unset,\n    setResultRequest: RequestState.Unset,\n    finishedGames: [],\n    gameBets: {}\n};\n\nlet _odds: Odds[] = [];\n\nfunction updateState(updateFn: (oldState: State) => State) {\n    state = updateFn(state);\n    self.postMessage(state);\n}\n\ntype Actions = CreateBetAction\n    | LoginPageOpened\n    | Initialize\n    | RegisterAction\n    | LogoutAction\n    | UpdateScoreboardAction\n    | SetResultAction\n    | ShowGameBets;\n\nasync function syncGames() {\n    let headers = new Headers();\n    if (state.accessToken) {\n        headers.append(\"Authorization\", `Bearer ${state.accessToken.token}`);\n    }\n    headers.append(\"X-Frontend-Version\", \"1\");\n    let gamesRes = await fetch(`${environment.serverUrl}/games`, { headers: headers });\n    let games: Game[] = await gamesRes.json();\n    updateState(s => {\n        return {\n            ...s,\n            upcomingGames: games.filter(g => !g.result).map(g => {\n                let oldGame = s.upcomingGames.find(o => o.id == g.id);\n                return {\n                    ...oldGame,\n                    id: g.id,\n                    team1: g.team1,\n                    team2: g.team2,\n                    time: new Date(g.time),\n                    myBet: g.myBet ? {\n                        choice: g.myBet.choice,\n                        odds: {\n                            team1: g.myBet.odds.team1Odds,\n                            team2: g.myBet.odds.team2Odds,\n                            draw: g.myBet.odds.drawOdds\n                        }\n                    } : null\n                };\n            }).sort((a, b) => +a.time - +b.time),\n            finishedGames: games.filter(g => g.result).map(g => {\n                let oldGame = s.finishedGames.find(o => o.id == g.id);\n                return {\n                    ...oldGame,\n                    id: g.id,\n                    team1: g.team1,\n                    team2: g.team2,\n                    time: new Date(g.time),\n                    myBet: g.myBet ? {\n                        choice: g.myBet.choice,\n                        odds: {\n                            team1: g.myBet.odds.team1Odds,\n                            team2: g.myBet.odds.team2Odds,\n                            draw: g.myBet.odds.drawOdds\n                        }\n                    } : null,\n                    result: {\n                        team1Goals: g.result.team1Goals,\n                        team2Goals: g.result.team2Goals\n                    }\n                }\n            }).sort((a, b) => +b.time - +a.time)\n        }\n    });\n}\n\nasync function getOdds() {\n    let oddsRes = await fetch(`${environment.serverUrl}/odds`);\n    _odds = await oddsRes.json();\n    return _odds;\n}\n\nasync function getGames() {\n    let syncGamesTask = syncGames();\n    let getOddsTask = getOdds();\n    let [_, odds] = await Promise.all([syncGamesTask, getOddsTask]);\n    updateState(s => {\n        let upcomingGames = [...s.upcomingGames];\n        for (let o of odds) {\n            let game = upcomingGames.find(g => o.gameId == g.id);\n            if (game && +game.time > (+new Date() - 5 * 60000)) {\n                let idx = upcomingGames.indexOf(game);\n                upcomingGames[idx] = {\n                    ...game, odds: {\n                        draw: o.drawOdds,\n                        id: o.id,\n                        team1: o.team1Odds,\n                        team2: o.team2Odds,\n                    }\n                };\n            }\n        }\n        return {\n            ...s,\n            upcomingGames: upcomingGames\n        }\n    });\n}\n\nfunction updateUpcomingGame(id: number, update: Partial<UpcomingGame>) {\n    updateState(s => {\n        let upcomingGames = [...s.upcomingGames];\n        let game = upcomingGames.find(g => id == g.id);\n        let idx = upcomingGames.indexOf(game);\n        upcomingGames[idx] = {\n            ...game,\n            ...update\n        };\n        return {\n            ...s,\n            upcomingGames: upcomingGames\n        };\n    });\n}\n\nasync function createBet(msg: CreateBetAction) {\n    let foundOdds = _odds.find(o => o.id == msg.oddsId);\n    updateUpcomingGame(foundOdds.gameId, { saving: true, saveError: null });\n    if (null == state.accessToken) {\n        updateState(s => { return { ...s, goToLogin: true } });\n    } else if (null == state.userId) {\n        updateState(s => { return { ...s, goToRegister: true } });\n    }\n    try {\n        let res = await fetch(`${environment.serverUrl}/bets`, {\n            headers: {\n                \"Authorization\": `Bearer ${state.accessToken.token}`,\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify({ oddsId: msg.oddsId, choice: msg.choice })\n        });\n        if (res.status == 200) {\n            updateUpcomingGame(foundOdds.gameId, {\n                myBet: {\n                    choice: msg.choice,\n                    odds: {\n                        draw: foundOdds.drawOdds,\n                        team1: foundOdds.team1Odds,\n                        team2: foundOdds.team2Odds\n                    }\n                },\n                saving: false\n            });\n        } else if (res.status == 400) {\n            let err: { type: string } = await res.json();\n            if (err.type == \"oddschanged\" || err.type == \"oddsexpired\") {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: {\n                        oddsChanged: true\n                    }\n                });\n                await getGames();\n            } else if (err.type == \"gamestarted\") {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: {\n                        gameStarted: true\n                    }\n                });\n                await getGames();\n            } else {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: { unknown: true }\n                });\n            }\n        }\n    } catch (err) {\n        updateUpcomingGame(foundOdds.gameId, {\n            saving: false, saveError: { unknown: true }\n        });\n    }\n}\n\nasync function initializeAccessToken(accessToken: AccessToken) {\n    let res = await fetch(`${environment.serverUrl}/user/profile`, {\n        headers: {\n            \"Authorization\": `Bearer ${accessToken.token}`\n        }\n    });\n    if (res.status == 401) {\n        updateState(s => {\n            return {\n                ...s,\n                goToRegister: true,\n                accessToken: accessToken\n            };\n        });\n    } else if (res.status == 200) {\n        let userProfile: Profile = await res.json();\n        updateState(s => {\n            return {\n                ...s,\n                accessToken: accessToken,\n                userId: userProfile.userId,\n                displayName: userProfile.displayName\n            };\n        });\n        return true;\n    }\n    return false;\n\n}\n\nasync function initialize(accessToken: AccessToken) {\n    if (accessToken) {\n        await initializeAccessToken(accessToken);\n    }\n    await getGames();\n}\n\nasync function register(msg: RegisterAction) {\n    updateState(s => { return { ...s, register: RequestState.InProgress, goToRegister: false } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/user/register`, {\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify({ displayName: msg.displayName, token: state.accessToken.token })\n        });\n        if (res.status == 201) {\n            if (await initializeAccessToken(state.accessToken)) {\n                updateState(s => { return { ...s, register: RequestState.Successful } });\n            }\n        } else {\n            updateState(s => { return { ...s, register: RequestState.Failed } });\n        }\n    } catch (err) {\n        updateState(s => { return { ...s, register: RequestState.Failed } });\n    }\n}\n\nasync function logout(smg: LogoutAction) {\n    if (\"credentials\" in navigator && \"preventSilentAccess\" in navigator.credentials) {\n        navigator.credentials.preventSilentAccess();\n    }\n    updateState(s => {\n        return {\n            ...s,\n            accessToken: null,\n            displayName: null,\n            userId: null\n        }\n    });\n    await getGames();\n}\n\nasync function updateScoreboard(msg: UpdateScoreboardAction) {\n    updateState(s => { return { ...s, scoreboardRequest: RequestState.InProgress } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/scoreboard`);\n        if (!res.ok) {\n            updateState(s => { return { ...s, scoreboardRequest: RequestState.Failed } });\n            return;\n        }\n        let content: ScoreboardEntry[] = await res.json();\n        let scoreboard = content.sort((a, b) => {\n            return b.points - a.points || a.displayName.localeCompare(b.displayName);\n        }).map(s => {\n            return {\n                displayName: s.displayName,\n                points: s.points,\n                userId: s.userId\n            };\n        })\n        updateState(s => {\n            return {\n                ...s,\n                scoreboardRequest: RequestState.Successful,\n                scoreboard: scoreboard\n            }\n        });\n    } catch (err) {\n        updateState(s => { return { ...s, scoreboardRequest: RequestState.Failed } });\n    }\n}\n\nasync function getGameBets(msg: ShowGameBets) {\n    updateState(s => { return { ...s, gameBets: { ...s.gameBets, [msg.gameId]: { ...s.gameBets[msg.gameId], requestState: RequestState.InProgress } } } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/games/${msg.gameId}/bets`);\n        if (!res.ok) {\n            updateState(s => { return { ...s, gameBets: { ...s.gameBets, [msg.gameId]: { ...s.gameBets[msg.gameId], requestState: RequestState.Failed } } } });\n            return;\n        }\n        let content: UserBet[] = await res.json();\n        updateState(s => {\n            return {\n                ...s, gameBets: {\n                    ...s.gameBets, [msg.gameId]: {\n                        ...s.gameBets[msg.gameId],\n                        requestState: RequestState.Successful,\n                        bets: content.map(b => {\n                            return {\n                                displayName: b.displayName,\n                                choice: b.choice,\n                                userId: b.userId\n                            };\n                        })\n                    }\n                }\n            }\n        });\n    } catch (err) {\n        updateState(s => { return { ...s, gameBets: { ...s.gameBets, [msg.gameId]: { ...s.gameBets[msg.gameId], requestState: RequestState.Failed } } } });\n    }\n}\n\nasync function setResult(msg: SetResultAction) {\n    updateState(s => { return { ...s, setResultRequest: RequestState.InProgress } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/games/${msg.gameId}/result`, {\n            headers: {\n                \"Authorization\": `Bearer ${state.accessToken.token}`,\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"PUT\",\n            body: JSON.stringify({ team1Goals: msg.team1Goals, team2Goals: msg.team2Goals })\n        });\n        if (res.ok) {\n            updateState(s => { return { ...s, setResultRequest: RequestState.Successful } });\n        } else {\n            updateState(s => { return { ...s, setResultRequest: RequestState.Failed } });\n        }\n    } catch (err) {\n        updateState(s => { return { ...s, setResultRequest: RequestState.Failed } });\n    }\n}\n\nasync function handleMessage(msg: Actions) {\n    switch (msg.type) {\n        case ActionType.CreateBet:\n            await createBet(msg);\n            break;\n        case ActionType.LoginPageOpened:\n            updateState(s => { return { ...s, goToLogin: false } });\n            break;\n        case ActionType.Initialize:\n            await initialize(msg.accessToken);\n            break;\n        case ActionType.Register:\n            await register(msg);\n            break;\n        case ActionType.Logout:\n            await logout(msg);\n            break;\n        case ActionType.UpdateScoreboard:\n            await updateScoreboard(msg);\n            break;\n        case ActionType.SetResult:\n            await setResult(msg);\n            break;\n        case ActionType.ShowGameBets:\n            await getGameBets(msg);\n            break;\n    }\n}\n\nself.addEventListener(\"message\", ev => {\n    let msg: Actions = ev.data;\n    handleMessage(msg).catch(err => console.error(err));\n});"],"sourceRoot":""}