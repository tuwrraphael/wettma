{"version":3,"sources":["webpack://wettma/./src/state/state.ts","webpack://wettma/./src/environment.ts","webpack://wettma/./src/state/worker.ts"],"names":["RequestState","serverUrl","environment","state","upcomingGames","goToLogin","goToRegister","accessToken","displayName","userId","register","Unset","scoreboard","scoreboardRequest","setResultRequest","finishedGames","_odds","updateState","updateFn","self","postMessage","async","getGames","syncGamesTask","headers","Headers","append","token","gamesRes","fetch","games","json","s","filter","g","result","map","oldGame","find","o","id","team1","team2","time","Date","myBet","choice","odds","team1Odds","team2Odds","draw","drawOdds","sort","a","b","team1Goals","team2Goals","syncGames","getOddsTask","oddsRes","getOdds","_","Promise","all","game","gameId","idx","indexOf","updateUpcomingGame","update","initializeAccessToken","res","status","userProfile","addEventListener","ev","msg","type","foundOdds","oddsId","saving","saveError","method","body","JSON","stringify","err","oddsChanged","gameStarted","unknown","createBet","initialize","InProgress","Successful","Failed","smg","navigator","credentials","preventSilentAccess","logout","ok","points","localeCompare","updateScoreboard","setResult","handleMessage","data","catch","console","error"],"mappings":"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","file":"ebb8f67f2f9dfe412ace.bundle.js","sourcesContent":["import { AccessToken } from \"../AccessToken\";\nimport { ScoreboardEntry } from \"../models/ScoreboardEntry\";\nimport { FinishedGame, UpcomingGame } from \"../models/UpcomingGame\";\n\nexport enum RequestState {\n    Unset,\n    InProgress,\n    Successful,\n    Failed,\n}\n\nexport interface State {\n    goToLogin: boolean;\n    upcomingGames: UpcomingGame[];\n    finishedGames : FinishedGame[];\n    accessToken: AccessToken;\n    goToRegister: boolean;\n    displayName: string;\n    userId: string;\n    register: RequestState;\n    scoreboardRequest: RequestState;\n    scoreboard: ScoreboardEntry[];\n    setResultRequest: RequestState\n}\n","let serverUrl: string;\n\nif (__ENVIRONMENT == \"local\") {\n    serverUrl = \"https://localhost:44308\";\n}\nelse if (__ENVIRONMENT == \"gh-pages\") {\n    serverUrl = \"https://wettma.azurewebsites.net\";\n}\n\nexport const environment = {\n    serverUrl: serverUrl\n};\n","import { RequestState, State } from \"./state\";\nimport { LoginPageOpened } from \"./requests/LoginPageOpened\";\nimport { CreateBetAction } from \"./requests/CreateBetAction\";\nimport { ActionType } from \"./requests/ActionType\";\nimport { environment } from \"../environment\";\nimport { Game, Odds, Profile, ScoreboardEntry } from \"../api/models\";\nimport { Initialize } from \"./requests/Initialize\";\nimport { RegisterAction } from \"./requests/RegisterAction\";\nimport { AccessToken } from \"../AccessToken\";\nimport { LogoutAction } from \"./requests/LogoutAction\";\nimport { UpcomingGame } from \"../models/UpcomingGame\";\nimport { UpdateScoreboardAction } from \"./requests/UpdateScoreboardAction\";\nimport { SetResultAction } from \"./requests/SetResultAction\";\n\nlet state: State = {\n    upcomingGames: [],\n    goToLogin: false,\n    goToRegister: false,\n    accessToken: null,\n    displayName: null,\n    userId: null,\n    register: RequestState.Unset,\n    scoreboard: [],\n    scoreboardRequest: RequestState.Unset,\n    setResultRequest: RequestState.Unset,\n    finishedGames: []\n};\n\nlet _odds: Odds[] = [];\n\nfunction updateState(updateFn: (oldState: State) => State) {\n    state = updateFn(state);\n    self.postMessage(state);\n}\n\ntype Actions = CreateBetAction\n    | LoginPageOpened\n    | Initialize\n    | RegisterAction\n    | LogoutAction\n    | UpdateScoreboardAction\n    | SetResultAction;\n\nasync function syncGames() {\n    let headers = new Headers();\n    if (state.accessToken) {\n        headers.append(\"Authorization\", `Bearer ${state.accessToken.token}`);\n    }\n    let gamesRes = await fetch(`${environment.serverUrl}/games`, { headers: headers });\n    let games: Game[] = await gamesRes.json();\n    updateState(s => {\n        return {\n            ...s,\n            upcomingGames: games.filter(g => !g.result).map(g => {\n                let oldGame = s.upcomingGames.find(o => o.id == g.id);\n                return {\n                    ...oldGame,\n                    id: g.id,\n                    team1: g.team1,\n                    team2: g.team2,\n                    time: new Date(g.time),\n                    myBet: g.myBet ? {\n                        choice: g.myBet.choice,\n                        odds: {\n                            team1: g.myBet.odds.team1Odds,\n                            team2: g.myBet.odds.team2Odds,\n                            draw: g.myBet.odds.drawOdds\n                        }\n                    } : null\n                };\n            }).sort((a, b) => +a.time - +b.time),\n            finishedGames: games.filter(g => g.result).map(g => {\n                return {\n                    id: g.id,\n                    team1: g.team1,\n                    team2: g.team2,\n                    time: new Date(g.time),\n                    myBet: g.myBet ? {\n                        choice: g.myBet.choice,\n                        odds: {\n                            team1: g.myBet.odds.team1Odds,\n                            team2: g.myBet.odds.team2Odds,\n                            draw: g.myBet.odds.drawOdds\n                        }\n                    } : null,\n                    result: {\n                        team1Goals: g.result.team1Goals,\n                        team2Goals: g.result.team2Goals\n                    }\n                }\n            }).sort((a, b) => +b.time - +a.time)\n        }\n    });\n}\n\nasync function getOdds() {\n    let oddsRes = await fetch(`${environment.serverUrl}/odds`);\n    _odds = await oddsRes.json();\n    return _odds;\n}\n\nasync function getGames() {\n    let syncGamesTask = syncGames();\n    let getOddsTask = getOdds();\n    let [_, odds] = await Promise.all([syncGamesTask, getOddsTask]);\n    updateState(s => {\n        let upcomingGames = [...s.upcomingGames];\n        for (let o of odds) {\n            let game = upcomingGames.find(g => o.gameId == g.id);\n            if (game && +game.time > (+new Date() - 5 * 60000)) {\n                let idx = upcomingGames.indexOf(game);\n                upcomingGames[idx] = {\n                    ...game, odds: {\n                        draw: o.drawOdds,\n                        id: o.id,\n                        team1: o.team1Odds,\n                        team2: o.team2Odds,\n                    }\n                };\n            }\n        }\n        return {\n            ...s,\n            upcomingGames: upcomingGames\n        }\n    });\n}\n\nfunction updateUpcomingGame(id: number, update: Partial<UpcomingGame>) {\n    updateState(s => {\n        let upcomingGames = [...s.upcomingGames];\n        let game = upcomingGames.find(g => id == g.id);\n        let idx = upcomingGames.indexOf(game);\n        upcomingGames[idx] = {\n            ...game,\n            ...update\n        };\n        return {\n            ...s,\n            upcomingGames: upcomingGames\n        };\n    });\n}\n\nasync function createBet(msg: CreateBetAction) {\n    let foundOdds = _odds.find(o => o.id == msg.oddsId);\n    updateUpcomingGame(foundOdds.gameId, { saving: true, saveError: null });\n    if (null == state.accessToken) {\n        updateState(s => { return { ...s, goToLogin: true } });\n    } else if (null == state.userId) {\n        updateState(s => { return { ...s, goToRegister: true } });\n    }\n    try {\n        let res = await fetch(`${environment.serverUrl}/bets`, {\n            headers: {\n                \"Authorization\": `Bearer ${state.accessToken.token}`,\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify({ oddsId: msg.oddsId, choice: msg.choice })\n        });\n        if (res.status == 200) {\n            updateUpcomingGame(foundOdds.gameId, {\n                myBet: {\n                    choice: msg.choice,\n                    odds: {\n                        draw: foundOdds.drawOdds,\n                        team1: foundOdds.team1Odds,\n                        team2: foundOdds.team2Odds\n                    }\n                },\n                saving: false\n            });\n        } else if (res.status == 400) {\n            let err: { type: string } = await res.json();\n            if (err.type == \"oddschanged\" || err.type == \"oddsexpired\") {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: {\n                        oddsChanged: true\n                    }\n                });\n                await getGames();\n            } else if (err.type == \"gamestarted\") {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: {\n                        gameStarted: true\n                    }\n                });\n                await getGames();\n            } else {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: { unknown: true }\n                });\n            }\n        }\n    } catch (err) {\n        updateUpcomingGame(foundOdds.gameId, {\n            saving: false, saveError: { unknown: true }\n        });\n    }\n}\n\nasync function initializeAccessToken(accessToken: AccessToken) {\n    let res = await fetch(`${environment.serverUrl}/user/profile`, {\n        headers: {\n            \"Authorization\": `Bearer ${accessToken.token}`\n        }\n    });\n    if (res.status == 401) {\n        updateState(s => {\n            return {\n                ...s,\n                goToRegister: true,\n                accessToken: accessToken\n            };\n        });\n    } else if (res.status == 200) {\n        let userProfile: Profile = await res.json();\n        updateState(s => {\n            return {\n                ...s,\n                accessToken: accessToken,\n                userId: userProfile.userId,\n                displayName: userProfile.displayName\n            };\n        });\n        return true;\n    }\n    return false;\n\n}\n\nasync function initialize(accessToken: AccessToken) {\n    if (accessToken) {\n        await initializeAccessToken(accessToken);\n    }\n    await getGames();\n}\n\nasync function register(msg: RegisterAction) {\n    updateState(s => { return { ...s, register: RequestState.InProgress, goToRegister: false } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/user/register`, {\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify({ displayName: msg.displayName, token: state.accessToken.token })\n        });\n        if (res.status == 201) {\n            if (await initializeAccessToken(state.accessToken)) {\n                updateState(s => { return { ...s, register: RequestState.Successful } });\n            }\n        } else {\n            updateState(s => { return { ...s, register: RequestState.Failed } });\n        }\n    } catch (err) {\n        updateState(s => { return { ...s, register: RequestState.Failed } });\n    }\n}\n\nasync function logout(smg: LogoutAction) {\n    if (\"credentials\" in navigator && \"preventSilentAccess\" in navigator.credentials) {\n        navigator.credentials.preventSilentAccess();\n    }\n    updateState(s => {\n        return {\n            ...s,\n            accessToken: null,\n            displayName: null,\n            userId: null\n        }\n    });\n    await getGames();\n}\n\nasync function updateScoreboard(msg: UpdateScoreboardAction) {\n    updateState(s => { return { ...s, scoreboardRequest: RequestState.InProgress } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/scoreboard`);\n        if (!res.ok) {\n            updateState(s => { return { ...s, scoreboardRequest: RequestState.Failed } });\n            return;\n        }\n        let content: ScoreboardEntry[] = await res.json();\n        let scoreboard = content.sort((a, b) => {\n            return b.points - a.points || a.displayName.localeCompare(b.displayName);\n        }).map(s => {\n            return {\n                displayName: s.displayName,\n                points: s.points,\n                userId: s.userId\n            };\n        })\n        updateState(s => {\n            return {\n                ...s,\n                scoreboardRequest: RequestState.Successful,\n                scoreboard: scoreboard\n            }\n        });\n    } catch (err) {\n        updateState(s => { return { ...s, scoreboardRequest: RequestState.Failed } });\n    }\n}\n\nasync function setResult(msg: SetResultAction) {\n    updateState(s => { return { ...s, setResultRequest: RequestState.InProgress } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/games/${msg.gameId}/result`, {\n            headers: {\n                \"Authorization\": `Bearer ${state.accessToken.token}`,\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"PUT\",\n            body: JSON.stringify({ team1Goals: msg.team1Goals, team2Goals: msg.team2Goals })\n        });\n        if (res.ok) {\n            updateState(s => { return { ...s, setResultRequest: RequestState.Successful } });\n        } else {\n            updateState(s => { return { ...s, setResultRequest: RequestState.Failed } });\n        }\n    } catch (err) {\n        updateState(s => { return { ...s, setResultRequest: RequestState.Failed } });\n    }\n}\n\nasync function handleMessage(msg: Actions) {\n    switch (msg.type) {\n        case ActionType.CreateBet:\n            await createBet(msg);\n            break;\n        case ActionType.LoginPageOpened:\n            updateState(s => { return { ...s, goToLogin: false } });\n            break;\n        case ActionType.Initialize:\n            await initialize(msg.accessToken);\n            break;\n        case ActionType.Register:\n            await register(msg);\n            break;\n        case ActionType.Logout:\n            await logout(msg);\n            break;\n        case ActionType.UpdateScoreboard:\n            await updateScoreboard(msg);\n            break;\n        case ActionType.SetResult:\n            await setResult(msg);\n            break;\n    }\n}\n\nself.addEventListener(\"message\", ev => {\n    let msg: Actions = ev.data;\n    handleMessage(msg).catch(err => console.error(err));\n});"],"sourceRoot":""}