{"version":3,"file":"5d9a83f5111cad02b2de.bundle.js","mappings":"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","sources":["webpack://wettma/./src/state/state.ts","webpack://wettma/./src/environment.ts","webpack://wettma/./src/state/worker.ts"],"sourcesContent":["import { AccessToken } from \"../AccessToken\";\nimport { ScoreboardEntry } from \"../models/ScoreboardEntry\";\nimport { UpcomingGame } from \"../models/UpcomingGame\";\nimport { FinishedGame } from \"../models/FinishedGame\";\nimport { GameBets } from \"../models/GameBets\";\n\nexport enum RequestState {\n    Unset,\n    InProgress,\n    Successful,\n    Failed\n}\n\nexport interface State {\n    goToLogin: boolean;\n    upcomingGames: UpcomingGame[];\n    finishedGames: FinishedGame[];\n    accessToken: AccessToken;\n    goToRegister: boolean;\n    displayName: string;\n    userId: string;\n    register: RequestState;\n    scoreboardRequest: RequestState;\n    scoreboard: ScoreboardEntry[];\n    setResultRequest: RequestState;\n    placeComputerBetsRequest: RequestState;\n    gameBets: { [gameId: number]: GameBets },\n    hasMoreFinishedGames : boolean\n}\n","let serverUrl: string;\n\nif (__ENVIRONMENT == \"local\") {\n    serverUrl = \"https://localhost:44308\";\n}\nelse if (__ENVIRONMENT == \"gh-pages\") {\n    serverUrl = \"https://wettma.azurewebsites.net\";\n}\n\nexport const environment = {\n    serverUrl: serverUrl\n};\n","import { RequestState, State } from \"./state\";\nimport { LoginPageOpened } from \"./requests/LoginPageOpened\";\nimport { CreateBetAction } from \"./requests/CreateBetAction\";\nimport { ActionType } from \"./requests/ActionType\";\nimport { environment } from \"../environment\";\nimport { Game, Odds, Profile, ScoreboardEntry, UserBet } from \"../api/models\";\nimport { Initialize } from \"./requests/Initialize\";\nimport { RegisterAction } from \"./requests/RegisterAction\";\nimport { AccessToken } from \"../AccessToken\";\nimport { LogoutAction } from \"./requests/LogoutAction\";\nimport { UpcomingGame } from \"../models/UpcomingGame\";\nimport { UpdateScoreboardAction } from \"./requests/UpdateScoreboardAction\";\nimport { SetResultAction } from \"./requests/SetResultAction\";\nimport { ShowGameBets } from \"./requests/ShowGameBets\";\nimport { FinishedGame } from \"../models/FinishedGame\";\nimport { ShowMoreFinishedGamesAction } from \"./requests/ShowMoreFinishedGames\";\nimport { PlaceComputerBetsAction } from \"./requests/PlaceComputerBetsAction\";\nimport { ComputerBet } from \"../models/GameBets\";\n\n\nlet isStandalone: boolean = null;\n\nlet finishedGames: FinishedGame[] = [];\nconst initialFinishedGames = 5;\nconst finishedGamesIncrement = 10;\n\nconst contest = 3;\n\nlet state: State = {\n    upcomingGames: [],\n    goToLogin: false,\n    goToRegister: false,\n    accessToken: null,\n    displayName: null,\n    userId: null,\n    register: RequestState.Unset,\n    scoreboard: [],\n    scoreboardRequest: RequestState.Unset,\n    setResultRequest: RequestState.Unset,\n    placeComputerBetsRequest: RequestState.Unset,\n    finishedGames: [],\n    gameBets: {},\n    hasMoreFinishedGames: false\n};\n\nlet _odds: Odds[] = [];\n\nfunction updateState(updateFn: (oldState: State) => State) {\n    state = updateFn(state);\n    self.postMessage(state);\n}\n\ntype Actions = CreateBetAction\n    | LoginPageOpened\n    | Initialize\n    | RegisterAction\n    | LogoutAction\n    | UpdateScoreboardAction\n    | SetResultAction\n    | ShowGameBets\n    | ShowMoreFinishedGamesAction\n    | PlaceComputerBetsAction;\n\nasync function syncGames() {\n    let headers = new Headers();\n    if (state.accessToken) {\n        headers.append(\"Authorization\", `Bearer ${state.accessToken.token}`);\n    }\n    headers.append(\"X-Frontend-Version\", \"1\");\n    if (null != isStandalone) {\n        headers.append(\"X-Frontend-Standalone\", isStandalone ? \"true\" : \"false\");\n    }\n    let gamesRes = await fetch(`${environment.serverUrl}/games?contestId=${contest}`, { headers: headers });\n    let games: Game[] = await gamesRes.json();\n    finishedGames = games.filter(g => g.result).map(g => {\n        let oldGame = finishedGames.find(o => o.id == g.id);\n        return {\n            ...oldGame,\n            id: g.id,\n            team1: g.team1,\n            team2: g.team2,\n            time: new Date(g.time),\n            myBet: g.myBet ? {\n                choice: g.myBet.choice,\n                odds: {\n                    team1: g.myBet.odds.team1Odds,\n                    team2: g.myBet.odds.team2Odds,\n                    draw: g.myBet.odds.drawOdds\n                }\n            } : null,\n            result: {\n                team1Goals: g.result.team1Goals,\n                team2Goals: g.result.team2Goals\n            },\n            points: g.points\n        }\n    }).sort((a, b) => +b.time - +a.time);\n    updateState(s => {\n        let stateFinishedGames = finishedGames.slice(0, finishedGames.length > initialFinishedGames ? initialFinishedGames : finishedGames.length);\n        return {\n            ...s,\n            upcomingGames: games.filter(g => !g.result).map(g => {\n                let oldGame = s.upcomingGames.find(o => o.id == g.id);\n                return {\n                    ...oldGame,\n                    id: g.id,\n                    team1: g.team1,\n                    team2: g.team2,\n                    time: new Date(g.time),\n                    myBet: g.myBet ? {\n                        choice: g.myBet.choice,\n                        odds: {\n                            team1: g.myBet.odds.team1Odds,\n                            team2: g.myBet.odds.team2Odds,\n                            draw: g.myBet.odds.drawOdds\n                        }\n                    } : null,\n                    points: g.points\n                };\n            }).sort((a, b) => +a.time - +b.time),\n            finishedGames: stateFinishedGames,\n            hasMoreFinishedGames: stateFinishedGames.length < finishedGames.length\n        }\n    });\n}\n\nasync function getOdds() {\n    let oddsRes = await fetch(`${environment.serverUrl}/odds?contestId=${contest}`);\n    _odds = await oddsRes.json();\n    return _odds;\n}\n\nasync function getGames() {\n    let syncGamesTask = syncGames();\n    let getOddsTask = getOdds();\n    let [_, odds] = await Promise.all([syncGamesTask, getOddsTask]);\n    updateState(s => {\n        let upcomingGames = [...s.upcomingGames];\n        for (let o of odds) {\n            let game = upcomingGames.find(g => o.gameId == g.id);\n            if (game && +game.time > (+new Date() - 5 * 60000)) {\n                let idx = upcomingGames.indexOf(game);\n                upcomingGames[idx] = {\n                    ...game, odds: {\n                        draw: o.drawOdds,\n                        id: o.id,\n                        team1: o.team1Odds,\n                        team2: o.team2Odds,\n                    }\n                };\n            }\n        }\n        return {\n            ...s,\n            upcomingGames: upcomingGames\n        }\n    });\n}\n\nfunction updateUpcomingGame(id: number, update: Partial<UpcomingGame>) {\n    updateState(s => {\n        let upcomingGames = [...s.upcomingGames];\n        let game = upcomingGames.find(g => id == g.id);\n        let idx = upcomingGames.indexOf(game);\n        upcomingGames[idx] = {\n            ...game,\n            ...update\n        };\n        return {\n            ...s,\n            upcomingGames: upcomingGames\n        };\n    });\n}\n\nasync function createBet(msg: CreateBetAction) {\n    let foundOdds = _odds.find(o => o.id == msg.oddsId);\n    updateUpcomingGame(foundOdds.gameId, { saving: true, saveError: null });\n    if (null == state.accessToken) {\n        updateState(s => { return { ...s, goToLogin: true } });\n    } else if (null == state.userId) {\n        updateState(s => { return { ...s, goToRegister: true } });\n    }\n    try {\n        let res = await fetch(`${environment.serverUrl}/bets`, {\n            headers: {\n                \"Authorization\": `Bearer ${state.accessToken.token}`,\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify({ oddsId: msg.oddsId, choice: msg.choice })\n        });\n        if (res.status == 200) {\n            updateUpcomingGame(foundOdds.gameId, {\n                myBet: {\n                    choice: msg.choice,\n                    odds: {\n                        draw: foundOdds.drawOdds,\n                        team1: foundOdds.team1Odds,\n                        team2: foundOdds.team2Odds\n                    }\n                },\n                saving: false\n            });\n        } else if (res.status == 400) {\n            let err: { type: string } = await res.json();\n            if (err.type == \"oddschanged\" || err.type == \"oddsexpired\") {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: {\n                        oddsChanged: true\n                    }\n                });\n                await getGames();\n            } else if (err.type == \"gamestarted\") {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: {\n                        gameStarted: true\n                    }\n                });\n                await getGames();\n            } else {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: { unknown: true }\n                });\n            }\n        }\n    } catch (err) {\n        updateUpcomingGame(foundOdds.gameId, {\n            saving: false, saveError: { unknown: true }\n        });\n    }\n}\n\nasync function initializeAccessToken(accessToken: AccessToken) {\n    let res = await fetch(`${environment.serverUrl}/user/profile`, {\n        headers: {\n            \"Authorization\": `Bearer ${accessToken.token}`\n        }\n    });\n    if (res.status == 401) {\n        updateState(s => {\n            return {\n                ...s,\n                goToRegister: true,\n                accessToken: accessToken\n            };\n        });\n    } else if (res.status == 200) {\n        let userProfile: Profile = await res.json();\n        updateState(s => {\n            return {\n                ...s,\n                accessToken: accessToken,\n                userId: userProfile.userId,\n                displayName: userProfile.displayName\n            };\n        });\n        return true;\n    }\n    return false;\n\n}\n\nasync function initialize(msg: Initialize) {\n    isStandalone = msg.isStandalone;\n    if (msg.accessToken) {\n        await initializeAccessToken(msg.accessToken);\n    }\n    await getGames();\n}\n\nasync function register(msg: RegisterAction) {\n    updateState(s => { return { ...s, register: RequestState.InProgress, goToRegister: false } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/user/register`, {\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify({ displayName: msg.displayName, token: state.accessToken.token })\n        });\n        if (res.status == 201) {\n            if (await initializeAccessToken(state.accessToken)) {\n                updateState(s => { return { ...s, register: RequestState.Successful } });\n            }\n        } else {\n            updateState(s => { return { ...s, register: RequestState.Failed } });\n        }\n    } catch (err) {\n        updateState(s => { return { ...s, register: RequestState.Failed } });\n    }\n}\n\nasync function logout(smg: LogoutAction) {\n    if (\"credentials\" in navigator && \"preventSilentAccess\" in navigator.credentials) {\n        navigator.credentials.preventSilentAccess();\n    }\n    updateState(s => {\n        return {\n            ...s,\n            accessToken: null,\n            displayName: null,\n            userId: null\n        }\n    });\n    await getGames();\n}\n\nasync function updateScoreboard(msg: UpdateScoreboardAction) {\n    updateState(s => { return { ...s, scoreboardRequest: RequestState.InProgress } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/scoreboard?contestId=${contest}`);\n        if (!res.ok) {\n            updateState(s => { return { ...s, scoreboardRequest: RequestState.Failed } });\n            return;\n        }\n        let content: ScoreboardEntry[] = await res.json();\n        let scoreboard = content.sort((a, b) => {\n            return b.points - a.points || a.displayName.localeCompare(b.displayName);\n        }).map((s, idx) => {\n            return {\n                displayName: s.displayName,\n                points: s.points,\n                userId: s.userId,\n                place: idx + 1\n            };\n        })\n        updateState(s => {\n            return {\n                ...s,\n                scoreboardRequest: RequestState.Successful,\n                scoreboard: scoreboard\n            }\n        });\n    } catch (err) {\n        updateState(s => { return { ...s, scoreboardRequest: RequestState.Failed } });\n    }\n}\n\nasync function getGameBets(msg: ShowGameBets) {\n    updateState(s => {\n        return {\n            ...s, gameBets: {\n                ...s.gameBets, [msg.gameId]: {\n                    ...s.gameBets[msg.gameId], requestState: RequestState.InProgress,\n                    computerBetRequestState: RequestState.InProgress\n                }\n            }\n        }\n    });\n    try {\n        let res = await fetch(`${environment.serverUrl}/games/${msg.gameId}/bets`);\n        if (!res.ok) {\n            updateState(s => { return { ...s, gameBets: { ...s.gameBets, [msg.gameId]: { ...s.gameBets[msg.gameId], requestState: RequestState.Failed } } } });\n            return;\n        }\n        let content: UserBet[] = await res.json();\n        updateState(s => {\n            return {\n                ...s, gameBets: {\n                    ...s.gameBets, [msg.gameId]: {\n                        ...s.gameBets[msg.gameId],\n                        requestState: RequestState.Successful,\n                        bets: content.map(b => {\n                            return {\n                                displayName: b.displayName,\n                                choice: b.choice,\n                                userId: b.userId\n                            };\n                        })\n                    }\n                }\n            }\n        });\n    } catch (err) {\n        updateState(s => { return { ...s, gameBets: { ...s.gameBets, [msg.gameId]: { ...s.gameBets[msg.gameId], requestState: RequestState.Failed } } } });\n    }\n    try {\n        let res = await fetch(`${environment.serverUrl}/computer/games/${msg.gameId}/bets`);\n        if (!res.ok) {\n            updateState(s => { return { ...s, gameBets: { ...s.gameBets, [msg.gameId]: { ...s.gameBets[msg.gameId], computerBetRequestState: RequestState.Failed } } } });\n            return;\n        }\n        let content: ComputerBet[] = await res.json();\n        updateState(s => {\n            return {\n                ...s, gameBets: {\n                    ...s.gameBets, [msg.gameId]: {\n                        ...s.gameBets[msg.gameId],\n                        computerBetRequestState: RequestState.Successful,\n                        computerBets: content.map(b => {\n                            return {\n                                displayName: b.displayName,\n                                choice: b.choice,\n                                reason: b.reason,\n                                computerPlayerId: b.computerPlayerId\n                            };\n                        })\n                    }\n                }\n            }\n        });\n    } catch (err) {\n        updateState(s => { return { ...s, gameBets: { ...s.gameBets, [msg.gameId]: { ...s.gameBets[msg.gameId], requestState: RequestState.Failed } } } });\n    }\n}\n\nasync function setResult(msg: SetResultAction) {\n    updateState(s => { return { ...s, setResultRequest: RequestState.InProgress } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/games/${msg.gameId}/result`, {\n            headers: {\n                \"Authorization\": `Bearer ${state.accessToken.token}`,\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"PUT\",\n            body: JSON.stringify({ team1Goals: msg.team1Goals, team2Goals: msg.team2Goals })\n        });\n        if (res.ok) {\n            updateState(s => { return { ...s, setResultRequest: RequestState.Successful } });\n        } else {\n            updateState(s => { return { ...s, setResultRequest: RequestState.Failed } });\n        }\n    } catch (err) {\n        updateState(s => { return { ...s, setResultRequest: RequestState.Failed } });\n    }\n}\n\nasync function placeComputerBets(msg: PlaceComputerBetsAction) {\n    updateState(s => { return { ...s, placeComputerBetsRequest: RequestState.InProgress } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/computer/bets`, {\n            headers: {\n                \"Authorization\": `Bearer ${state.accessToken.token}`,\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify(msg.request)\n        });\n        if (res.ok) {\n            updateState(s => { return { ...s, placeComputerBetsRequest: RequestState.Successful } });\n        } else {\n            updateState(s => { return { ...s, placeComputerBetsRequest: RequestState.Failed } });\n        }\n    } catch (err) {\n        updateState(s => { return { ...s, placeComputerBetsRequest: RequestState.Failed } });\n    }\n}\n\nasync function showMoreFinishedGames() {\n    updateState(s => {\n        let numFinishedGames = s.finishedGames.length + finishedGamesIncrement;\n        let stateFinishedGames = finishedGames.slice(0, finishedGames.length > numFinishedGames ? numFinishedGames : finishedGames.length);\n        return {\n            ...s,\n            finishedGames: stateFinishedGames,\n            hasMoreFinishedGames: stateFinishedGames.length < finishedGames.length\n        }\n    });\n}\n\nasync function handleMessage(msg: Actions) {\n    switch (msg.type) {\n        case ActionType.CreateBet:\n            await createBet(msg);\n            break;\n        case ActionType.LoginPageOpened:\n            updateState(s => { return { ...s, goToLogin: false } });\n            break;\n        case ActionType.Initialize:\n            await initialize(msg);\n            break;\n        case ActionType.Register:\n            await register(msg);\n            break;\n        case ActionType.Logout:\n            await logout(msg);\n            break;\n        case ActionType.UpdateScoreboard:\n            await updateScoreboard(msg);\n            break;\n        case ActionType.SetResult:\n            await setResult(msg);\n            break;\n        case ActionType.PlaceComputerBets:\n            await placeComputerBets(msg);\n            break;\n        case ActionType.ShowGameBets:\n            await getGameBets(msg);\n            break;\n        case ActionType.ShowMoreFinishedGames:\n            await showMoreFinishedGames();\n            break;\n    }\n}\n\nself.addEventListener(\"message\", ev => {\n    let msg: Actions = ev.data;\n    handleMessage(msg).catch(err => console.error(err));\n});"],"names":["RequestState","serverUrl","environment","isStandalone","finishedGames","state","upcomingGames","goToLogin","goToRegister","accessToken","displayName","userId","register","Unset","scoreboard","scoreboardRequest","setResultRequest","placeComputerBetsRequest","gameBets","hasMoreFinishedGames","_odds","updateState","updateFn","self","postMessage","async","getGames","syncGamesTask","headers","Headers","append","token","gamesRes","fetch","games","json","filter","g","result","map","oldGame","find","o","id","team1","team2","time","Date","myBet","choice","odds","team1Odds","team2Odds","draw","drawOdds","team1Goals","team2Goals","points","sort","a","b","s","stateFinishedGames","slice","length","syncGames","getOddsTask","oddsRes","getOdds","_","Promise","all","game","gameId","idx","indexOf","updateUpcomingGame","update","initializeAccessToken","res","status","userProfile","addEventListener","ev","msg","type","foundOdds","oddsId","saving","saveError","method","body","JSON","stringify","err","oddsChanged","gameStarted","unknown","createBet","initialize","InProgress","Successful","Failed","smg","navigator","credentials","preventSilentAccess","logout","ok","localeCompare","place","updateScoreboard","setResult","request","placeComputerBets","Object","requestState","computerBetRequestState","content","bets","computerBets","reason","computerPlayerId","getGameBets","numFinishedGames","showMoreFinishedGames","handleMessage","data","catch","console","error"],"sourceRoot":""}