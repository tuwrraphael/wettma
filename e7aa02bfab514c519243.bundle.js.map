{"version":3,"file":"e7aa02bfab514c519243.bundle.js","mappings":"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","sources":["webpack://wettma/./src/state/state.ts","webpack://wettma/./src/environment.ts","webpack://wettma/./src/state/worker.ts"],"sourcesContent":["import { AccessToken } from \"../AccessToken\";\nimport { ScoreboardEntry } from \"../models/ScoreboardEntry\";\nimport { UpcomingGame } from \"../models/UpcomingGame\";\nimport { FinishedGame } from \"../models/FinishedGame\";\nimport { GameBets } from \"../models/GameBets\";\n\nexport enum RequestState {\n    Unset,\n    InProgress,\n    Successful,\n    Failed\n}\n\nexport interface State {\n    goToLogin: boolean;\n    upcomingGames: UpcomingGame[];\n    finishedGames: FinishedGame[];\n    accessToken: AccessToken;\n    goToRegister: boolean;\n    displayName: string;\n    userId: string;\n    register: RequestState;\n    scoreboardRequest: RequestState;\n    scoreboard: ScoreboardEntry[];\n    setResultRequest: RequestState;\n    placeComputerBetsRequest: RequestState;\n    gameBets: { [gameId: number]: GameBets },\n    hasMoreFinishedGames: boolean,\n    participants: { userId: string, displayName: string }[]\n}\n","let serverUrl: string;\n\nif (__ENVIRONMENT == \"local\") {\n    serverUrl = \"https://localhost:44308\";\n}\nelse if (__ENVIRONMENT == \"gh-pages\") {\n    serverUrl = \"https://wettma.azurewebsites.net\";\n}\n\nexport const environment = {\n    serverUrl: serverUrl\n};\n","import { RequestState, State } from \"./state\";\nimport { LoginPageOpened } from \"./requests/LoginPageOpened\";\nimport { CreateBetAction } from \"./requests/CreateBetAction\";\nimport { ActionType } from \"./requests/ActionType\";\nimport { environment } from \"../environment\";\nimport { Game, Odds, Profile, ScoreboardEntry, UserBet } from \"../api/models\";\nimport { Initialize } from \"./requests/Initialize\";\nimport { RegisterAction } from \"./requests/RegisterAction\";\nimport { AccessToken } from \"../AccessToken\";\nimport { LogoutAction } from \"./requests/LogoutAction\";\nimport { UpcomingGame } from \"../models/UpcomingGame\";\nimport { UpdateScoreboardAction } from \"./requests/UpdateScoreboardAction\";\nimport { SetResultAction } from \"./requests/SetResultAction\";\nimport { ShowGameBets } from \"./requests/ShowGameBets\";\nimport { FinishedGame } from \"../models/FinishedGame\";\nimport { ShowMoreFinishedGamesAction } from \"./requests/ShowMoreFinishedGames\";\nimport { PlaceComputerBetsAction } from \"./requests/PlaceComputerBetsAction\";\nimport { ComputerBet } from \"../models/GameBets\";\nimport { LoadParticipantsAction } from \"./requests/LoadParticipantsAction\";\n\n\nlet isStandalone: boolean = null;\n\nlet finishedGames: FinishedGame[] = [];\nconst initialFinishedGames = 5;\nconst finishedGamesIncrement = 10;\n\nconst contest = 3;\n\nlet state: State = {\n    upcomingGames: [],\n    goToLogin: false,\n    goToRegister: false,\n    accessToken: null,\n    displayName: null,\n    userId: null,\n    register: RequestState.Unset,\n    scoreboard: [],\n    scoreboardRequest: RequestState.Unset,\n    setResultRequest: RequestState.Unset,\n    placeComputerBetsRequest: RequestState.Unset,\n    finishedGames: [],\n    gameBets: {},\n    hasMoreFinishedGames: false,\n    participants: []\n};\n\nlet _odds: Odds[] = [];\n\nfunction updateState(updateFn: (oldState: State) => State) {\n    state = updateFn(state);\n    self.postMessage(state);\n}\n\ntype Actions = CreateBetAction\n    | LoginPageOpened\n    | Initialize\n    | RegisterAction\n    | LogoutAction\n    | UpdateScoreboardAction\n    | SetResultAction\n    | ShowGameBets\n    | ShowMoreFinishedGamesAction\n    | PlaceComputerBetsAction\n    | LoadParticipantsAction;\n\nlet queued: Actions[] = [];\n\nasync function syncGames() {\n    let headers = new Headers();\n    if (state.accessToken) {\n        headers.append(\"Authorization\", `Bearer ${state.accessToken.token}`);\n    }\n    headers.append(\"X-Frontend-Version\", \"1\");\n    if (null != isStandalone) {\n        headers.append(\"X-Frontend-Standalone\", isStandalone ? \"true\" : \"false\");\n    }\n    let gamesRes = await fetch(`${environment.serverUrl}/games?contestId=${contest}`, { headers: headers });\n    let games: Game[] = await gamesRes.json();\n    finishedGames = games.filter(g => g.result).map(g => {\n        let oldGame = finishedGames.find(o => o.id == g.id);\n        return {\n            ...oldGame,\n            id: g.id,\n            team1: g.team1,\n            team2: g.team2,\n            time: new Date(g.time),\n            myBet: g.myBet ? {\n                choice: g.myBet.choice,\n                odds: {\n                    team1: g.myBet.odds.team1Odds,\n                    team2: g.myBet.odds.team2Odds,\n                    draw: g.myBet.odds.drawOdds\n                }\n            } : null,\n            result: {\n                team1Goals: g.result.team1Goals,\n                team2Goals: g.result.team2Goals\n            },\n            points: g.points\n        }\n    }).sort((a, b) => +b.time - +a.time);\n    updateState(s => {\n        let stateFinishedGames = finishedGames.slice(0, finishedGames.length > initialFinishedGames ? initialFinishedGames : finishedGames.length);\n        return {\n            ...s,\n            upcomingGames: games.filter(g => !g.result).map(g => {\n                let oldGame = s.upcomingGames.find(o => o.id == g.id);\n                return {\n                    ...oldGame,\n                    id: g.id,\n                    team1: g.team1,\n                    team2: g.team2,\n                    time: new Date(g.time),\n                    myBet: g.myBet ? {\n                        choice: g.myBet.choice,\n                        odds: {\n                            team1: g.myBet.odds.team1Odds,\n                            team2: g.myBet.odds.team2Odds,\n                            draw: g.myBet.odds.drawOdds\n                        }\n                    } : null,\n                    points: g.points\n                };\n            }).sort((a, b) => +a.time - +b.time),\n            finishedGames: stateFinishedGames,\n            hasMoreFinishedGames: stateFinishedGames.length < finishedGames.length\n        }\n    });\n}\n\nasync function getOdds() {\n    let oddsRes = await fetch(`${environment.serverUrl}/odds?contestId=${contest}`);\n    _odds = await oddsRes.json();\n    return _odds;\n}\n\nasync function getGames() {\n    let syncGamesTask = syncGames();\n    let getOddsTask = getOdds();\n    let [_, odds] = await Promise.all([syncGamesTask, getOddsTask]);\n    updateState(s => {\n        let upcomingGames = [...s.upcomingGames];\n        for (let o of odds) {\n            let game = upcomingGames.find(g => o.gameId == g.id);\n            if (game && +game.time > (+new Date() - 5 * 60000)) {\n                let idx = upcomingGames.indexOf(game);\n                upcomingGames[idx] = {\n                    ...game, odds: {\n                        draw: o.drawOdds,\n                        id: o.id,\n                        team1: o.team1Odds,\n                        team2: o.team2Odds,\n                    }\n                };\n            }\n        }\n        return {\n            ...s,\n            upcomingGames: upcomingGames\n        }\n    });\n}\n\nfunction updateUpcomingGame(id: number, update: Partial<UpcomingGame>) {\n    updateState(s => {\n        let upcomingGames = [...s.upcomingGames];\n        let game = upcomingGames.find(g => id == g.id);\n        let idx = upcomingGames.indexOf(game);\n        upcomingGames[idx] = {\n            ...game,\n            ...update\n        };\n        return {\n            ...s,\n            upcomingGames: upcomingGames\n        };\n    });\n}\n\nasync function createBet(msg: CreateBetAction) {\n    let foundOdds = _odds.find(o => o.id == msg.oddsId);\n    updateUpcomingGame(foundOdds.gameId, { saving: true, saveError: null });\n    if (null == state.accessToken) {\n        updateState(s => { return { ...s, goToLogin: true } });\n    } else if (null == state.userId) {\n        updateState(s => { return { ...s, goToRegister: true } });\n    }\n    try {\n        let res = await fetch(`${environment.serverUrl}/bets`, {\n            headers: {\n                \"Authorization\": `Bearer ${state.accessToken.token}`,\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify({ oddsId: msg.oddsId, choice: msg.choice })\n        });\n        if (res.status == 200) {\n            updateUpcomingGame(foundOdds.gameId, {\n                myBet: {\n                    choice: msg.choice,\n                    odds: {\n                        draw: foundOdds.drawOdds,\n                        team1: foundOdds.team1Odds,\n                        team2: foundOdds.team2Odds\n                    }\n                },\n                saving: false\n            });\n        } else if (res.status == 400) {\n            let err: { type: string } = await res.json();\n            if (err.type == \"oddschanged\" || err.type == \"oddsexpired\") {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: {\n                        oddsChanged: true\n                    }\n                });\n                await getGames();\n            } else if (err.type == \"gamestarted\") {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: {\n                        gameStarted: true\n                    }\n                });\n                await getGames();\n            } else {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: { unknown: true }\n                });\n            }\n        }\n    } catch (err) {\n        updateUpcomingGame(foundOdds.gameId, {\n            saving: false, saveError: { unknown: true }\n        });\n    }\n}\n\nasync function initializeAccessToken(accessToken: AccessToken) {\n    let res = await fetch(`${environment.serverUrl}/user/profile`, {\n        headers: {\n            \"Authorization\": `Bearer ${accessToken.token}`\n        }\n    });\n    if (res.status == 401) {\n        updateState(s => {\n            return {\n                ...s,\n                goToRegister: true,\n                accessToken: accessToken\n            };\n        });\n    } else if (res.status == 200) {\n        let userProfile: Profile = await res.json();\n        updateState(s => {\n            return {\n                ...s,\n                accessToken: accessToken,\n                userId: userProfile.userId,\n                displayName: userProfile.displayName\n            };\n        });\n        return true;\n    }\n    return false;\n\n}\n\nasync function initialize(msg: Initialize) {\n    isStandalone = msg.isStandalone;\n    if (msg.accessToken) {\n        await initializeAccessToken(msg.accessToken);\n    }\n    await getGames();\n    if (queued.length > 0) {\n        for (let q of queued) {\n            await handleMessage(q);\n        }\n        queued = [];\n    }\n}\n\nasync function register(msg: RegisterAction) {\n    updateState(s => { return { ...s, register: RequestState.InProgress, goToRegister: false } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/user/register`, {\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify({ displayName: msg.displayName, token: state.accessToken.token })\n        });\n        if (res.status == 201) {\n            if (await initializeAccessToken(state.accessToken)) {\n                updateState(s => { return { ...s, register: RequestState.Successful } });\n            }\n        } else {\n            updateState(s => { return { ...s, register: RequestState.Failed } });\n        }\n    } catch (err) {\n        updateState(s => { return { ...s, register: RequestState.Failed } });\n    }\n}\n\nasync function logout(smg: LogoutAction) {\n    if (\"credentials\" in navigator && \"preventSilentAccess\" in navigator.credentials) {\n        navigator.credentials.preventSilentAccess();\n    }\n    updateState(s => {\n        return {\n            ...s,\n            accessToken: null,\n            displayName: null,\n            userId: null\n        }\n    });\n    await getGames();\n}\n\nasync function updateScoreboard(msg: UpdateScoreboardAction) {\n    updateState(s => { return { ...s, scoreboardRequest: RequestState.InProgress } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/scoreboard?contestId=${contest}`);\n        if (!res.ok) {\n            updateState(s => { return { ...s, scoreboardRequest: RequestState.Failed } });\n            return;\n        }\n        let content: ScoreboardEntry[] = await res.json();\n        let scoreboard = content.sort((a, b) => {\n            return b.points - a.points || a.displayName.localeCompare(b.displayName);\n        }).map((s, idx) => {\n            return {\n                displayName: s.displayName,\n                points: s.points,\n                userId: s.userId,\n                place: idx + 1\n            };\n        })\n        updateState(s => {\n            return {\n                ...s,\n                scoreboardRequest: RequestState.Successful,\n                scoreboard: scoreboard\n            }\n        });\n    } catch (err) {\n        updateState(s => { return { ...s, scoreboardRequest: RequestState.Failed } });\n    }\n}\n\nasync function updateParticipants(msg: LoadParticipantsAction) {\n    try {\n        let res = await fetch(`${environment.serverUrl}/participants?contestId=${contest}`, {\n            headers: {\n                \"Authorization\": `Bearer ${state.accessToken.token}`,\n            }\n        });\n        if (!res.ok) {\n            return;\n        }\n        let participants: { userId: string, displayName: string }[] = await res.json();\n        updateState(s => {\n            return {\n                ...s,\n                participants: participants\n            }\n        });\n    } catch (err) {\n        console.error(err);\n    }\n}\n\nasync function getGameBets(msg: ShowGameBets) {\n    updateState(s => {\n        return {\n            ...s, gameBets: {\n                ...s.gameBets, [msg.gameId]: {\n                    ...s.gameBets[msg.gameId], requestState: RequestState.InProgress,\n                    computerBetRequestState: RequestState.InProgress\n                }\n            }\n        }\n    });\n    try {\n        let res = await fetch(`${environment.serverUrl}/games/${msg.gameId}/bets`);\n        if (!res.ok) {\n            updateState(s => { return { ...s, gameBets: { ...s.gameBets, [msg.gameId]: { ...s.gameBets[msg.gameId], requestState: RequestState.Failed } } } });\n            return;\n        }\n        let content: UserBet[] = await res.json();\n        updateState(s => {\n            return {\n                ...s, gameBets: {\n                    ...s.gameBets, [msg.gameId]: {\n                        ...s.gameBets[msg.gameId],\n                        requestState: RequestState.Successful,\n                        bets: content.map(b => {\n                            return {\n                                displayName: b.displayName,\n                                choice: b.choice,\n                                userId: b.userId\n                            };\n                        })\n                    }\n                }\n            }\n        });\n    } catch (err) {\n        updateState(s => { return { ...s, gameBets: { ...s.gameBets, [msg.gameId]: { ...s.gameBets[msg.gameId], requestState: RequestState.Failed } } } });\n    }\n    try {\n        let res = await fetch(`${environment.serverUrl}/computer/games/${msg.gameId}/bets`);\n        if (!res.ok) {\n            updateState(s => { return { ...s, gameBets: { ...s.gameBets, [msg.gameId]: { ...s.gameBets[msg.gameId], computerBetRequestState: RequestState.Failed } } } });\n            return;\n        }\n        let content: ComputerBet[] = await res.json();\n        updateState(s => {\n            return {\n                ...s, gameBets: {\n                    ...s.gameBets, [msg.gameId]: {\n                        ...s.gameBets[msg.gameId],\n                        computerBetRequestState: RequestState.Successful,\n                        computerBets: content.map(b => {\n                            return {\n                                displayName: b.displayName,\n                                choice: b.choice,\n                                reason: b.reason,\n                                computerPlayerId: b.computerPlayerId\n                            };\n                        })\n                    }\n                }\n            }\n        });\n    } catch (err) {\n        updateState(s => { return { ...s, gameBets: { ...s.gameBets, [msg.gameId]: { ...s.gameBets[msg.gameId], requestState: RequestState.Failed } } } });\n    }\n}\n\nasync function setResult(msg: SetResultAction) {\n    updateState(s => { return { ...s, setResultRequest: RequestState.InProgress } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/games/${msg.gameId}/result`, {\n            headers: {\n                \"Authorization\": `Bearer ${state.accessToken.token}`,\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"PUT\",\n            body: JSON.stringify({ team1Goals: msg.team1Goals, team2Goals: msg.team2Goals })\n        });\n        if (res.ok) {\n            updateState(s => { return { ...s, setResultRequest: RequestState.Successful } });\n        } else {\n            updateState(s => { return { ...s, setResultRequest: RequestState.Failed } });\n        }\n    } catch (err) {\n        updateState(s => { return { ...s, setResultRequest: RequestState.Failed } });\n    }\n}\n\nasync function placeComputerBets(msg: PlaceComputerBetsAction) {\n    updateState(s => { return { ...s, placeComputerBetsRequest: RequestState.InProgress } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/computer/bets`, {\n            headers: {\n                \"Authorization\": `Bearer ${state.accessToken.token}`,\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify(msg.request)\n        });\n        if (res.ok) {\n            updateState(s => { return { ...s, placeComputerBetsRequest: RequestState.Successful } });\n        } else {\n            updateState(s => { return { ...s, placeComputerBetsRequest: RequestState.Failed } });\n        }\n    } catch (err) {\n        updateState(s => { return { ...s, placeComputerBetsRequest: RequestState.Failed } });\n    }\n}\n\nasync function showMoreFinishedGames() {\n    updateState(s => {\n        let numFinishedGames = s.finishedGames.length + finishedGamesIncrement;\n        let stateFinishedGames = finishedGames.slice(0, finishedGames.length > numFinishedGames ? numFinishedGames : finishedGames.length);\n        return {\n            ...s,\n            finishedGames: stateFinishedGames,\n            hasMoreFinishedGames: stateFinishedGames.length < finishedGames.length\n        }\n    });\n}\n\nasync function handleMessage(msg: Actions) {\n    if (!state.accessToken && [ActionType.LoadParticipants].includes(msg.type)) {\n        queued.push(msg);\n        return;\n    }\n    switch (msg.type) {\n        case ActionType.CreateBet:\n            await createBet(msg);\n            break;\n        case ActionType.LoginPageOpened:\n            updateState(s => { return { ...s, goToLogin: false } });\n            break;\n        case ActionType.Initialize:\n            await initialize(msg);\n            break;\n        case ActionType.Register:\n            await register(msg);\n            break;\n        case ActionType.Logout:\n            await logout(msg);\n            break;\n        case ActionType.UpdateScoreboard:\n            await updateScoreboard(msg);\n            break;\n        case ActionType.SetResult:\n            await setResult(msg);\n            break;\n        case ActionType.PlaceComputerBets:\n            await placeComputerBets(msg);\n            break;\n        case ActionType.ShowGameBets:\n            await getGameBets(msg);\n            break;\n        case ActionType.LoadParticipants:\n            await updateParticipants(msg);\n            break;\n        case ActionType.ShowMoreFinishedGames:\n            await showMoreFinishedGames();\n            break;\n    }\n}\n\nself.addEventListener(\"message\", ev => {\n    let msg: Actions = ev.data;\n    handleMessage(msg).catch(err => console.error(err));\n});"],"names":["RequestState","serverUrl","environment","isStandalone","finishedGames","state","upcomingGames","goToLogin","goToRegister","accessToken","displayName","userId","register","Unset","scoreboard","scoreboardRequest","setResultRequest","placeComputerBetsRequest","gameBets","hasMoreFinishedGames","participants","_odds","updateState","updateFn","self","postMessage","queued","async","getGames","syncGamesTask","headers","Headers","append","token","gamesRes","fetch","games","json","filter","g","result","map","oldGame","find","o","id","team1","team2","time","Date","myBet","choice","odds","team1Odds","team2Odds","draw","drawOdds","team1Goals","team2Goals","points","sort","a","b","s","stateFinishedGames","slice","length","syncGames","getOddsTask","oddsRes","getOdds","_","Promise","all","game","gameId","idx","indexOf","updateUpcomingGame","update","initializeAccessToken","res","status","userProfile","handleMessage","msg","includes","type","foundOdds","oddsId","saving","saveError","method","body","JSON","stringify","err","oddsChanged","gameStarted","unknown","createBet","q","initialize","InProgress","Successful","Failed","smg","navigator","credentials","preventSilentAccess","logout","ok","localeCompare","place","updateScoreboard","setResult","request","placeComputerBets","Object","requestState","computerBetRequestState","content","bets","computerBets","reason","computerPlayerId","getGameBets","console","error","updateParticipants","numFinishedGames","showMoreFinishedGames","push","addEventListener","ev","data","catch"],"sourceRoot":""}