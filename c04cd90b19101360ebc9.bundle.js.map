{"version":3,"sources":["webpack://wettma/./src/state/state.ts","webpack://wettma/./src/environment.ts","webpack://wettma/./src/state/worker.ts"],"names":["RequestState","serverUrl","environment","isStandalone","finishedGames","state","upcomingGames","goToLogin","goToRegister","accessToken","displayName","userId","register","Unset","scoreboard","scoreboardRequest","setResultRequest","gameBets","hasMoreFinishedGames","_odds","updateState","updateFn","self","postMessage","async","getGames","syncGamesTask","headers","Headers","append","token","gamesRes","fetch","games","json","filter","g","result","map","oldGame","find","o","id","team1","team2","time","Date","myBet","choice","odds","team1Odds","team2Odds","draw","drawOdds","team1Goals","team2Goals","points","sort","a","b","s","stateFinishedGames","slice","length","syncGames","getOddsTask","oddsRes","getOdds","_","Promise","all","game","gameId","idx","indexOf","updateUpcomingGame","update","initializeAccessToken","res","status","userProfile","addEventListener","ev","msg","type","foundOdds","oddsId","saving","saveError","method","body","JSON","stringify","err","oddsChanged","gameStarted","unknown","createBet","initialize","InProgress","Successful","Failed","smg","navigator","credentials","preventSilentAccess","logout","ok","localeCompare","place","updateScoreboard","setResult","requestState","content","bets","getGameBets","numFinishedGames","showMoreFinishedGames","handleMessage","data","catch","console","error"],"mappings":"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","file":"c04cd90b19101360ebc9.bundle.js","sourcesContent":["import { AccessToken } from \"../AccessToken\";\nimport { ScoreboardEntry } from \"../models/ScoreboardEntry\";\nimport { UpcomingGame } from \"../models/UpcomingGame\";\nimport { FinishedGame } from \"../models/FinishedGame\";\nimport { GameBets } from \"../models/GameBets\";\n\nexport enum RequestState {\n    Unset,\n    InProgress,\n    Successful,\n    Failed\n}\n\nexport interface State {\n    goToLogin: boolean;\n    upcomingGames: UpcomingGame[];\n    finishedGames: FinishedGame[];\n    accessToken: AccessToken;\n    goToRegister: boolean;\n    displayName: string;\n    userId: string;\n    register: RequestState;\n    scoreboardRequest: RequestState;\n    scoreboard: ScoreboardEntry[];\n    setResultRequest: RequestState;\n    gameBets: { [gameId: number]: GameBets },\n    hasMoreFinishedGames : boolean\n}\n","let serverUrl: string;\n\nif (__ENVIRONMENT == \"local\") {\n    serverUrl = \"https://localhost:44308\";\n}\nelse if (__ENVIRONMENT == \"gh-pages\") {\n    serverUrl = \"https://wettma.azurewebsites.net\";\n}\n\nexport const environment = {\n    serverUrl: serverUrl\n};\n","import { RequestState, State } from \"./state\";\nimport { LoginPageOpened } from \"./requests/LoginPageOpened\";\nimport { CreateBetAction } from \"./requests/CreateBetAction\";\nimport { ActionType } from \"./requests/ActionType\";\nimport { environment } from \"../environment\";\nimport { Game, Odds, Profile, ScoreboardEntry, UserBet } from \"../api/models\";\nimport { Initialize } from \"./requests/Initialize\";\nimport { RegisterAction } from \"./requests/RegisterAction\";\nimport { AccessToken } from \"../AccessToken\";\nimport { LogoutAction } from \"./requests/LogoutAction\";\nimport { UpcomingGame } from \"../models/UpcomingGame\";\nimport { UpdateScoreboardAction } from \"./requests/UpdateScoreboardAction\";\nimport { SetResultAction } from \"./requests/SetResultAction\";\nimport { ShowGameBets } from \"./requests/ShowGameBets\";\nimport { FinishedGame } from \"../models/FinishedGame\";\nimport { ShowMoreFinishedGamesAction } from \"./requests/ShowMoreFinishedGames\";\n\n\nlet isStandalone: boolean = null;\n\nlet finishedGames: FinishedGame[] = [];\nconst initialFinishedGames = 5;\nconst finishedGamesIncrement = 10;\n\nlet state: State = {\n    upcomingGames: [],\n    goToLogin: false,\n    goToRegister: false,\n    accessToken: null,\n    displayName: null,\n    userId: null,\n    register: RequestState.Unset,\n    scoreboard: [],\n    scoreboardRequest: RequestState.Unset,\n    setResultRequest: RequestState.Unset,\n    finishedGames: [],\n    gameBets: {},\n    hasMoreFinishedGames: false\n};\n\nlet _odds: Odds[] = [];\n\nfunction updateState(updateFn: (oldState: State) => State) {\n    state = updateFn(state);\n    self.postMessage(state);\n}\n\ntype Actions = CreateBetAction\n    | LoginPageOpened\n    | Initialize\n    | RegisterAction\n    | LogoutAction\n    | UpdateScoreboardAction\n    | SetResultAction\n    | ShowGameBets\n    | ShowMoreFinishedGamesAction;\n\nasync function syncGames() {\n    let headers = new Headers();\n    if (state.accessToken) {\n        headers.append(\"Authorization\", `Bearer ${state.accessToken.token}`);\n    }\n    headers.append(\"X-Frontend-Version\", \"1\");\n    if (null != isStandalone) {\n        headers.append(\"X-Frontend-Standalone\", isStandalone ? \"true\" : \"false\");\n    }\n    let gamesRes = await fetch(`${environment.serverUrl}/games`, { headers: headers });\n    let games: Game[] = await gamesRes.json();\n    finishedGames = games.filter(g => g.result).map(g => {\n        let oldGame = finishedGames.find(o => o.id == g.id);\n        return {\n            ...oldGame,\n            id: g.id,\n            team1: g.team1,\n            team2: g.team2,\n            time: new Date(g.time),\n            myBet: g.myBet ? {\n                choice: g.myBet.choice,\n                odds: {\n                    team1: g.myBet.odds.team1Odds,\n                    team2: g.myBet.odds.team2Odds,\n                    draw: g.myBet.odds.drawOdds\n                }\n            } : null,\n            result: {\n                team1Goals: g.result.team1Goals,\n                team2Goals: g.result.team2Goals\n            },\n            points: g.points\n        }\n    }).sort((a, b) => +b.time - +a.time);\n    updateState(s => {\n        let stateFinishedGames = finishedGames.slice(0, finishedGames.length > initialFinishedGames ? initialFinishedGames : finishedGames.length);\n        return {\n            ...s,\n            upcomingGames: games.filter(g => !g.result).map(g => {\n                let oldGame = s.upcomingGames.find(o => o.id == g.id);\n                return {\n                    ...oldGame,\n                    id: g.id,\n                    team1: g.team1,\n                    team2: g.team2,\n                    time: new Date(g.time),\n                    myBet: g.myBet ? {\n                        choice: g.myBet.choice,\n                        odds: {\n                            team1: g.myBet.odds.team1Odds,\n                            team2: g.myBet.odds.team2Odds,\n                            draw: g.myBet.odds.drawOdds\n                        }\n                    } : null,\n                    points: g.points\n                };\n            }).sort((a, b) => +a.time - +b.time),\n            finishedGames: stateFinishedGames,\n            hasMoreFinishedGames: stateFinishedGames.length < finishedGames.length\n        }\n    });\n}\n\nasync function getOdds() {\n    let oddsRes = await fetch(`${environment.serverUrl}/odds`);\n    _odds = await oddsRes.json();\n    return _odds;\n}\n\nasync function getGames() {\n    let syncGamesTask = syncGames();\n    let getOddsTask = getOdds();\n    let [_, odds] = await Promise.all([syncGamesTask, getOddsTask]);\n    updateState(s => {\n        let upcomingGames = [...s.upcomingGames];\n        for (let o of odds) {\n            let game = upcomingGames.find(g => o.gameId == g.id);\n            if (game && +game.time > (+new Date() - 5 * 60000)) {\n                let idx = upcomingGames.indexOf(game);\n                upcomingGames[idx] = {\n                    ...game, odds: {\n                        draw: o.drawOdds,\n                        id: o.id,\n                        team1: o.team1Odds,\n                        team2: o.team2Odds,\n                    }\n                };\n            }\n        }\n        return {\n            ...s,\n            upcomingGames: upcomingGames\n        }\n    });\n}\n\nfunction updateUpcomingGame(id: number, update: Partial<UpcomingGame>) {\n    updateState(s => {\n        let upcomingGames = [...s.upcomingGames];\n        let game = upcomingGames.find(g => id == g.id);\n        let idx = upcomingGames.indexOf(game);\n        upcomingGames[idx] = {\n            ...game,\n            ...update\n        };\n        return {\n            ...s,\n            upcomingGames: upcomingGames\n        };\n    });\n}\n\nasync function createBet(msg: CreateBetAction) {\n    let foundOdds = _odds.find(o => o.id == msg.oddsId);\n    updateUpcomingGame(foundOdds.gameId, { saving: true, saveError: null });\n    if (null == state.accessToken) {\n        updateState(s => { return { ...s, goToLogin: true } });\n    } else if (null == state.userId) {\n        updateState(s => { return { ...s, goToRegister: true } });\n    }\n    try {\n        let res = await fetch(`${environment.serverUrl}/bets`, {\n            headers: {\n                \"Authorization\": `Bearer ${state.accessToken.token}`,\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify({ oddsId: msg.oddsId, choice: msg.choice })\n        });\n        if (res.status == 200) {\n            updateUpcomingGame(foundOdds.gameId, {\n                myBet: {\n                    choice: msg.choice,\n                    odds: {\n                        draw: foundOdds.drawOdds,\n                        team1: foundOdds.team1Odds,\n                        team2: foundOdds.team2Odds\n                    }\n                },\n                saving: false\n            });\n        } else if (res.status == 400) {\n            let err: { type: string } = await res.json();\n            if (err.type == \"oddschanged\" || err.type == \"oddsexpired\") {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: {\n                        oddsChanged: true\n                    }\n                });\n                await getGames();\n            } else if (err.type == \"gamestarted\") {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: {\n                        gameStarted: true\n                    }\n                });\n                await getGames();\n            } else {\n                updateUpcomingGame(foundOdds.gameId, {\n                    saving: false, saveError: { unknown: true }\n                });\n            }\n        }\n    } catch (err) {\n        updateUpcomingGame(foundOdds.gameId, {\n            saving: false, saveError: { unknown: true }\n        });\n    }\n}\n\nasync function initializeAccessToken(accessToken: AccessToken) {\n    let res = await fetch(`${environment.serverUrl}/user/profile`, {\n        headers: {\n            \"Authorization\": `Bearer ${accessToken.token}`\n        }\n    });\n    if (res.status == 401) {\n        updateState(s => {\n            return {\n                ...s,\n                goToRegister: true,\n                accessToken: accessToken\n            };\n        });\n    } else if (res.status == 200) {\n        let userProfile: Profile = await res.json();\n        updateState(s => {\n            return {\n                ...s,\n                accessToken: accessToken,\n                userId: userProfile.userId,\n                displayName: userProfile.displayName\n            };\n        });\n        return true;\n    }\n    return false;\n\n}\n\nasync function initialize(msg: Initialize) {\n    isStandalone = msg.isStandalone;\n    if (msg.accessToken) {\n        await initializeAccessToken(msg.accessToken);\n    }\n    await getGames();\n}\n\nasync function register(msg: RegisterAction) {\n    updateState(s => { return { ...s, register: RequestState.InProgress, goToRegister: false } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/user/register`, {\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify({ displayName: msg.displayName, token: state.accessToken.token })\n        });\n        if (res.status == 201) {\n            if (await initializeAccessToken(state.accessToken)) {\n                updateState(s => { return { ...s, register: RequestState.Successful } });\n            }\n        } else {\n            updateState(s => { return { ...s, register: RequestState.Failed } });\n        }\n    } catch (err) {\n        updateState(s => { return { ...s, register: RequestState.Failed } });\n    }\n}\n\nasync function logout(smg: LogoutAction) {\n    if (\"credentials\" in navigator && \"preventSilentAccess\" in navigator.credentials) {\n        navigator.credentials.preventSilentAccess();\n    }\n    updateState(s => {\n        return {\n            ...s,\n            accessToken: null,\n            displayName: null,\n            userId: null\n        }\n    });\n    await getGames();\n}\n\nasync function updateScoreboard(msg: UpdateScoreboardAction) {\n    updateState(s => { return { ...s, scoreboardRequest: RequestState.InProgress } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/scoreboard`);\n        if (!res.ok) {\n            updateState(s => { return { ...s, scoreboardRequest: RequestState.Failed } });\n            return;\n        }\n        let content: ScoreboardEntry[] = await res.json();\n        let scoreboard = content.sort((a, b) => {\n            return b.points - a.points || a.displayName.localeCompare(b.displayName);\n        }).map((s, idx) => {\n            return {\n                displayName: s.displayName,\n                points: s.points,\n                userId: s.userId,\n                place: idx + 1\n            };\n        })\n        updateState(s => {\n            return {\n                ...s,\n                scoreboardRequest: RequestState.Successful,\n                scoreboard: scoreboard\n            }\n        });\n    } catch (err) {\n        updateState(s => { return { ...s, scoreboardRequest: RequestState.Failed } });\n    }\n}\n\nasync function getGameBets(msg: ShowGameBets) {\n    updateState(s => { return { ...s, gameBets: { ...s.gameBets, [msg.gameId]: { ...s.gameBets[msg.gameId], requestState: RequestState.InProgress } } } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/games/${msg.gameId}/bets`);\n        if (!res.ok) {\n            updateState(s => { return { ...s, gameBets: { ...s.gameBets, [msg.gameId]: { ...s.gameBets[msg.gameId], requestState: RequestState.Failed } } } });\n            return;\n        }\n        let content: UserBet[] = await res.json();\n        updateState(s => {\n            return {\n                ...s, gameBets: {\n                    ...s.gameBets, [msg.gameId]: {\n                        ...s.gameBets[msg.gameId],\n                        requestState: RequestState.Successful,\n                        bets: content.map(b => {\n                            return {\n                                displayName: b.displayName,\n                                choice: b.choice,\n                                userId: b.userId\n                            };\n                        })\n                    }\n                }\n            }\n        });\n    } catch (err) {\n        updateState(s => { return { ...s, gameBets: { ...s.gameBets, [msg.gameId]: { ...s.gameBets[msg.gameId], requestState: RequestState.Failed } } } });\n    }\n}\n\nasync function setResult(msg: SetResultAction) {\n    updateState(s => { return { ...s, setResultRequest: RequestState.InProgress } });\n    try {\n        let res = await fetch(`${environment.serverUrl}/games/${msg.gameId}/result`, {\n            headers: {\n                \"Authorization\": `Bearer ${state.accessToken.token}`,\n                \"Content-Type\": \"application/json\"\n            },\n            method: \"PUT\",\n            body: JSON.stringify({ team1Goals: msg.team1Goals, team2Goals: msg.team2Goals })\n        });\n        if (res.ok) {\n            updateState(s => { return { ...s, setResultRequest: RequestState.Successful } });\n        } else {\n            updateState(s => { return { ...s, setResultRequest: RequestState.Failed } });\n        }\n    } catch (err) {\n        updateState(s => { return { ...s, setResultRequest: RequestState.Failed } });\n    }\n}\n\nasync function showMoreFinishedGames() {\n    updateState(s => {\n        let numFinishedGames = s.finishedGames.length + finishedGamesIncrement;\n        let stateFinishedGames = finishedGames.slice(0, finishedGames.length > numFinishedGames ? numFinishedGames : finishedGames.length);\n        return {\n            ...s,\n            finishedGames: stateFinishedGames,\n            hasMoreFinishedGames: stateFinishedGames.length < finishedGames.length\n        }\n    });\n}\n\nasync function handleMessage(msg: Actions) {\n    switch (msg.type) {\n        case ActionType.CreateBet:\n            await createBet(msg);\n            break;\n        case ActionType.LoginPageOpened:\n            updateState(s => { return { ...s, goToLogin: false } });\n            break;\n        case ActionType.Initialize:\n            await initialize(msg);\n            break;\n        case ActionType.Register:\n            await register(msg);\n            break;\n        case ActionType.Logout:\n            await logout(msg);\n            break;\n        case ActionType.UpdateScoreboard:\n            await updateScoreboard(msg);\n            break;\n        case ActionType.SetResult:\n            await setResult(msg);\n            break;\n        case ActionType.ShowGameBets:\n            await getGameBets(msg);\n            break;\n        case ActionType.ShowMoreFinishedGames:\n            await showMoreFinishedGames();\n            break;\n    }\n}\n\nself.addEventListener(\"message\", ev => {\n    let msg: Actions = ev.data;\n    handleMessage(msg).catch(err => console.error(err));\n});"],"sourceRoot":""}